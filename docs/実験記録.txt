
										！！！注意！！！

　　このファイルは、やねうらおの開発時のメモです。備忘をかねて実験記録等を残しています。
　　内容の正確性等は保証しませんし、また、書いてある作業予定もやねうら王の公式のアナウンスではないです。
	この文書は、誰かに伝えるために書いているわけでもないので、意味不明なことは多々あるかと思います。
	予めご了承いただければと思います。

	-----------------------------------------------------------------------------------------------


ToDo: 
・kppの手番→ppの手番で代替できるような気が…。
・mate3()書く。


■ 2016/07/28

・1億局面生成のjob、片方途中で落ちてた。プロセスが落ちたのだろうか。
	VALUE_EVAL_MAXまで生成していることに関係しているのかも。
	困るなぁ…。再度落ちるようなら、ASSERT有効にして単体で走らせるしかあるまい。
	→　NUMA1のほうでデバッグで回しておく。

		start /NODE 1 /B /WAIT /D \\WS2012_860C_YAN\yanehome YaneuraOu.exe evaldir eval/179_0042G_V3 , threads 40 , hash 4096 , gensfen depth 6 loop 300000000 file \\WS2012_860C_YAN\yanehome\gen_sfen\00.bin , quit 

・棋譜生成、16手目まで定跡の指し手だが、もう少し先までやったほうがいいかも。
　あるいはもうちょっとなぞったほうがいいかも。

・depth3で10億生成してみるか。
	→　depth3にしたけど生成速度早くならん。なぜ？
	→　learnのほうでgensfenしてたような？

・Jenkins、master側再起動するとJob全部キャンセルするな…。再起動できないではないか…。
	→　Windows updateで再起動しないようにしておく。

・Jenkinsのmasterで実行できない件、workspaceフォルダ、該当ユーザーがフルコントロールに
　なってないからのようだ。
	→　フォルダに権限与えたところ実行できるようになった。

・局面生成、何が起きたのかわからないが20万局面を数秒で連続3回ぐらい生成してるタイミングがある。
	これ書き出し絡みのバグの可能性が…。

	書き出しthreadのバグなのか生成のバグなのか、ネットワークドライブが詰まっているのかが
	判然としない。生成スレッドのほう、
				cout << '[' << thread_id << ']';
	これ一行入れてテストする。
	→　一個書き込みしている間に複数queueに積まれることはありえるようではあるが…。
	→　ネットワークドライブが詰まるというのはあるのかも。
	→　違うようだ。ファイルの書き出しworkerで、論理スレッドいっぱいまで使っているためにcoutが詰まって、
	それゆえ、バッファ処理が少しずつ間に合わなくなるという問題があるようだ。
	coutが詰まるというよりネットワークドライブの書き出しで、書き出しのためのnet layerで詰まっているようだ。なるほど。
	なら、生成に問題があるわけではなさそう。

・連続自己対戦、engine configをpython側で生成するか。
	・フルスロットルで回せるべき。
	・numa指定できるべき。
	・records.sfenが実行ファイル直下固定なの、変更できるべき。
	・フォルダ名をコマンドライン引数などでpython側に渡すか…。
		→　テンプレからengine config持ってきて、python側で書き換えるか？
		エンジン名と評価関数とマッチング条件…。うーむ。書くの面倒だな、これ。
		・python2.7インストール
		環境変数pathの設定と、これを反映させるためのPCの再起動が必要なようだ…。うーん。
		c:\python27\python
		として実行して良いような気も…。
		とりあえずpathは通しておく。次の再起動のときになおるであろう。
	・python エンジン名1 evaldir1 エンジン名2 evaldir2 1手のms
		こう指定してengine configを生成するスクリプトを書くか。
		そして、engine configのフォルダ位置、変更できるようにする。
		→　pythonのスクリプト書けた。

			import sys

			def write_engine_file(num , engine_name , eval_dir , byoyomi):
				f = open("engine-config"+str(num)+".txt","w")
				f.write(engine_name+"\n")
				f.write("go btime 0 wtime 0 byoyomi "+byoyomi+"\n")
				f.write("setoption name EvalDir value " + eval_dir+"\n")
				f.write("setoption name Hash value 32\n")
				f.write("setoption name Threads value 1\n")
				f.write("setoption name NetworkDelay value 0\n")
				f.write("setoption name NetworkDelay2 value 0\n")

				f.close()

			param = sys.argv
			if len(param) != 6 :
				print " engine1 evaldir1 engine2 evaldir2 byoyomi"
				sys.exit()

			write_engine_file(1,param[1],param[2],param[5])
			write_engine_file(2,param[3],param[4],param[5])

	・local game serverにオプションいくつか追加。

			// "engine_configX.txt"が配置してあるフォルダ
			o["EngineConfigDir"] << Option("");

			// 子プロセスでEngineを実行するプロセッサグループ(Numa node)
			// -1なら、指定なし。
			o["EngineNuma"] << Option(-1, 0, 99999);

		CreateProcess、startコマンド呼べない。Node指定どうするのだ…。
				(LPWSTR)to_wstring("start /node 0 " + app_path_).c_str(),

		CreateProcessにSTARTUPINFOEXを指定するのか。情報少なすぎてわからん。

			  PPROC_THREAD_ATTRIBUTE_LIST attribs = { 0 };

			  size_t cb;
			  char sAttribsBuf[4096];
			  auto pAttribs = (PPROC_THREAD_ATTRIBUTE_LIST)sAttribsBuf;

			  if (!InitializeProcThreadAttributeList(NULL, 1, 0, &cb)
				  && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
				  return ;
			  if (!InitializeProcThreadAttributeList(pAttribs, 1, 0, &cb))
				  return ;

			  LPPROC_THREAD_ATTRIBUTE_LIST lpAttribs = (LPPROC_THREAD_ATTRIBUTE_LIST)sAttribsBuf;
			  if (!UpdateProcThreadAttribute(lpAttribs, 0, PROC_THREAD_ATTRIBUTE_PREFERRED_NODE
				  , &iNuma, sizeof(iNuma), NULL, NULL))
			  {
				  si.lpAttributeList = lpAttribs;

				  // これを反映させておき、STARTUPINFOEXが指定されていることをCreateProcessに示す必要がある。
				  si.StartupInfo.cb = sizeof(si);
			  }

		→　これやめよう。
			cmd.exe /c start /node 0 calc.exe
		こんな感じでcmd.exeから起動させよう。

		pythonだとこうか。

			import subprocess
			cmd = "cmd.exe /c start /node 0 calc.exe"
			subprocess.call( cmd.strip().split(" "))

		→　うまく動いている感じ。

			app_path_ = "cmd.exe /c start /B /WAIT /NODE " + to_string(numa) + " " + app_path_;

			/*
				/NODE
				Numa node(実行するプロセッサグループ)の指定

				/B
				実行したコマンドを別窓で開かないためのオプション。

				/WAIT
				/Bを指定したときにはこれを指定して、本窓の終了を待機しないと
				プロセス実行中に制御を抜けてしまい、file descriptorがleakする。
			*/

		→　やった！ここまでは意図通り動いた。

			あとは、さらにpython側からhookするコードを書けばいいのか…。大変だな、これまた。

			・BookSfenFileオプション追加。

			よしよし。あとは、

			・evalフォルダにサブフォルダがあるときにそれらをすべて対戦させるコード。
				→　書けた。

			・local-game-serverにフルスロットルで回すコード追加。
				→　出来た。

			・pythonで出力をリダイレクトして戦績を返すコード追加。
				→　それより先にgoコマンド終了時にquitさせることが出来ない。
				local game serverにおいてbyoyomi = 1なら終了後にquitするか。
				→　よくない実装。メインスレッドではないのでexit()できない。
			
				→　local-game-serverにおいて、goコマンドのあとstopで停止できないように変更する。
					そうしないとquitをqueueに積めない。
				→　うまく動いた。

				c:/python27/python.exe engine_invoker.py \\WS2012_860C_YAN\yanehome exe/YaneuraOuV347.exe eval/Apery20160505 exe/YaneuraOuV347.exe eval/learn_8 8 10 0 { 100 300 }

			// 以下、python側のコード。
			import sys
			import subprocess
			import os.path

			def write_engine_file(num , engine_name , eval_dir , byoyomi):
				f = open("engine-config"+str(num)+".txt","w")
				f.write(engine_name+"\n")
			#	f.write("go btime 0 wtime 0 byoyomi "+byoyomi+"\n")
				f.write("go rtime " + byoyomi + "\n")
				f.write("setoption name EvalDir value " + eval_dir+"\n")
				f.write("setoption name Hash value 16\n")
				f.write("setoption name Threads value 1\n")
				f.write("setoption name BookFile value no_book\n")
				f.write("setoption name NetworkDelay value 0\n")
				f.write("setoption name NetworkDelay2 value 0\n")

				f.close()

			param = sys.argv

			# args format
			# 	HOMEPATH engine1 evaldir1 engine2 evaldir2 threads loop numa { rtime1 ... rtimeN }

			# loop for invoker

			home = param[1]
			if not (home.endswith('/') or home.endswith('\\')):
				home += '\\'

			threads = param[6]
			loop = param[7]
			numa = param[8]

			if param[9] != "{" :
				byoyomi_list = param[9]
			else:
				byoyomi_list = []
				for i in range (10,len(param)-1):
					byoyomi_list.append(param[i])

			# expand eval_dir

			evaldirs = []
			if not os.path.exists(home + param[5] + "/0") :
				evaldirs.append(param[5])
			else:
				i = 0
				while os.path.exists(home + param[5] + "/" + str(i)):
					evaldirs.append(param[5] + "/" + str(i) )
					i += 1

			print "home         : " , home
			print "byoyomi_list : " , byoyomi_list
			print "evaldirs     : " , evaldirs

			for evaldir in evaldirs:

				print "engine1 = " + param[2] + " , eval = " + param[3]
				print "engine2 = " + param[4] + " , eval = " + evaldir

				for byoyomi in byoyomi_list:

					print "threads = " + threads + " , loop = " + loop + " , numa = " + numa + " , byoyomi = " + byoyomi
					write_engine_file(1,home + param[2],home + param[3],byoyomi)
					write_engine_file(2,home + param[4],home + evaldir,byoyomi)

					cmd = home + "\\exe\\local-game-serverV347.exe , booksfenfile " + home + "book/records1.sfen , threads " + threads + " , enginenuma " + numa + " , go btime " + loop + " , quit"

					# subprocess.call( cmd.strip().split(" "))
					print cmd
					p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
					stdout_data, stderr_data = p.communicate()
					# print "finish: \n%s\n%s" % (stdout_data, stderr_data)

					win = lose = draw = 0
					for line in stdout_data.split('\n'):
						if line.startswith("win"):
							win += 1
						elif line.startswith("lose"):
							lose += 1
						elif line.startswith("draw"):
							draw += 1

					total = win + lose
					if total != 0 :
						win_rate = 100 * win / float(win+lose)
					else:
						win_rate = 0
					print "finish " + str(win) + " - " + str(draw) + " - " + str(lose) + "(" + str(win_rate) + "%)\n"

				→　JenkinsのJob化、成功した。


■ 2016/07/27

・Jenkins Job化残り
	・学習のJob化
	→　できた…気がする。
	・連続自己対局のJob化
	→　あとで
	・gensfen、flush()してるのに、ネットワークドライブ上だと途中で終了すると保存されないな…。うーん..

・mkdir、フォルダ再帰的に作ってくれる？
	→　くれなかった。コマンドラインのmkdirは掘ってくれるのに…。

・連続自己対戦の改良
	・指定された回数、全スレッドでフルスロットルで回す
	・指定されたevaldirを順に変更して回す
	・学習と連携したいが、書き出しフォルダと切り離しているので出来ない。
	　evalの書き出しフォルダ、変更すべきか？
	→　よく考える。
	→　評価関数の書き出しをcontainerのなかにするとrobocopyが定期的にコピーしてしまい、
	余計なオーバーヘッドが発生するしな…。どうしたものか..さすがに80スレッドがネットワークドライブ上の
	同じ評価関数読み込むとなると80GBぐらいのトラフィックが発生してそれはそれで無駄だし…。
	いや、evalshareしてるから、それでもいいのか…。そうか…。
	なら学習回して、連続自己対戦までは自動化できそう。よしよし。
	あ、これ棋譜生成してるやつの評価関数使うと、それ学習してるのか。げろげろマズー。
	learnはevalshare offにしとかなきゃ。

		start /B /WAIT /NODE %EXECUTOR_NUMBER% robocopy \\Ws2012_860c_yan\e\jenkins_container  c:\jenkins/container /s /mir
		cd c:\jenkins\container
		mkdir \\Ws2012_860c_yan\e\jenkins_output\eval\%BUILD_NUMBER%
		start /NODE %EXECUTOR_NUMBER% /B /WAIT exe\YaneuraOuV345learn.exe evaldir %EVAL_DIR% , evalsavedir \\Ws2012_860c_yan\e\jenkins_output\eval\%BUILD_NUMBER% , threads 40 , hash 4096 , evalshare false , learn loop %LOOP_MAX% dir \\Ws2012_860c_yan\e\jenkins_output\learn_sfen  %KIF_FILES% , quit

	よしよし。出来てきた。
	連続自己対戦のJobまで書けたらJenkinsのバックアップをとる。

・考えまとまった。
	ネットワーク上の共有ドライブに何もかも配置したほうがいいという結論になった。
	robocopy不要になる。評価関数読み込むのは1つのJobにつきたかだか2回だけだし無視できるだろう。

	startコマンドの/Dでworkig directoryが指定できるようなのでこれを利用。
		例)
		start /NODE %EXECUTOR_NUMBER% /B /WAIT /D %YANEHOME% %YANEHOME%\exe\YaneuraOuV345.exe evaldir %EVAL_DIR% , threads %HT_CORES% , hash 4096 , gensfen depth %DEPTH% loop %LOOP_MAX% file %YANEHOME%\gen_sfen\%BUILD_NUMBER%.bin , quit
			HT_CORESに各nodeの論理コア数を入れておけば非対称なプロセッサでも大丈夫か。

	→　うまく動かん。startコマンド、スペースが入るとき""でpathくくるべきだが、
	  1つ目の""はwindow titleになるというstartコマンドの謎仕様。うむむ。
	→　よくわからん。Jenkinsのmasterだとネットワークドライブが見えないようだ。
	　サービスを動かしているuserが異なるからか？
		まあいいや。masterで動かさない。たぶん。

	例) 学習用
		mkdir %YANEHOME%\eval\learn_%BUILD_NUMBER%
		start /NODE %EXECUTOR_NUMBER% /B /WAIT /D %YANEHOME% %YANEHOME%\exe\YaneuraOuV345learn.exe evaldir %EVAL_DIR% , evalsavedir %YANEHOME%\eval\learn_%BUILD_NUMBER% , threads %HT_CORES% , hash 4096 , evalshare false , learn loop %LOOP_MAX% dir %YANEHOME%\learn_sfen  %KIF_FILES% , quit
		→　完璧。

・連続自己対戦用にやねうら王を改造する。
	・対戦条件を書いてファイルを食わせるとそれをやってくれると良いのか…な？
	→　ネットワークフォルダにそんなファイル置きたくないしな…。引数として指定できるといいのかな。
		よく考えよう…。
	→　まず、フルスロットルで回すコード追加するところからだ。

・学習のときにfinalizeするフォルダ名、
	learn_%BUILD_NUMBER%/f/
	とかのほうが良いのでは…。ここを固定しておかないと比較するときに難しくなる気が。
	そうでもないのかな…。
	→　そうでもない気がしてきた。

・eval limit=VALUE_EVAL_MAXで2億局面生成してSGDで1回まわして一つ前のものと比較。

		秒読み1000[ms]

		50.2%	
		#283
		やねうら王2016mid V344
		eval 179_0043G_V4
		#281
		やねうら王2016mid V344
		eval 179_0042G_V3

		1440-33-1426(39.7% R1.7)	

	ほぼ、変わらず？


■ 2016/07/26

・Jenkinsのテスト。
	・robocopyでミラーするjob作成
	→ JavaWebStartを使っていると実行権限が違って、ネットワークドライブが見れない。
	→　DCOMで実行するように変更。でも見れない。
		> whoami
		nt authority\system
	→　JenkinsのDCOMバグっているとしか思えん。
	→　ああ、UseLocal System Userであって、Jenkinsに入力したアカウントではないのか。これはあかん…。
	→　Jenkinsを実行しているWindowsのサービスを、指定ユーザーで実行するように変えれば良いのか。そうか。
	→　robocopyはできた。

	・NUMA、そもそも
	ビルド番号か何かで識別できないのか？
	https://wiki.jenkins-ci.org/display/JA/Building+a+software+project
	EXECUTOR_NUMBER	このビルドを実行するエグゼキューターを識別（同一マシン内で）するユニークな番号。
	"ビルド実行状態"で表示されている番号ですが、1ではなく0始まりです。
	→　これで出来そうな予感。%EXECUTOR_NUMBER% これで出来るわ。
	> start /NODE %EXECUTOR_NUMBER% robocopy ...
	こう書けばいいのか？
	→　よし、出来たっぽい。
	> start /NODE 0 robocopy \\Ws2012_860c_yan\e\jenkins_container  c:\jenkins/container /s /mir 
	→　よし、robocopy成功！
	
	・あと、同時実行されたときにフォルダが分かれて欲しいのだが..
	→　tempを必要とするなら、そのフォルダを分けるか。
		/{リモートFSルート}/workspace/{JOB_NAME}{EXECUTOR_NUMBER}
		こうなってくれないと困る。
	→ 自動的に、@2のようにJOB_NAMEの後ろにつくようだ。なら要らないのか、この機能は。

	Jenkins、MSBuildも使えるようなのでMSBuildでビルドしたほうが楽かも知れない。うむむ..
	msys2のmakeとか起動すると、numa nodeを指定できないか…。そんな問題があるのか…。うむむ…。
	普通にgitコマンドとMSBuildコマンド叩いたほうが賢いか。うむむ…。そんな気がしてきた。
	→　デプロイ少し楽になるかも知れないが、環境構築、面倒くさすぎる。
	→　2つの対戦をさせるのに２つGitHubから取ってきてMSBuildして対戦。うーん。それはいいような悪いような…。
	→　これはやめよう。

・Jenkinsのjob化していく。
	1) 局面生成をjob化
		・NUMA固定するためのプログラム考える。
		→　不要になった。

		・jobを細分化したいので、教師局面ファイルはもっと細切れに生成してconcatするべき。concatのプログラム書く。
		・生成された局面のgatherの手段、よく考える。

		→　とりあえずgensfenのファイル名を指定する手段を用意する。
		→　用意した。

			> start /NODE %EXECUTOR_NUMBER% exe/YaneuraOu.exe evaldir eval/179_0042G_V3 , threads 40 , hash 4096 , gensfen depth 6 loop 10000 file \\Ws2012_860c_yan\e\jenkins_output\kif1.bin , quit
			こんな感じでどうか。
			start /NODE 1 exe/YaneuraOuV345.exe evaldir eval/179_0042G_V3 , threads 40 , hash 4096 , gensfen depth 6 loop 100000 file \\Ws2012_860c_yan\e\jenkins_output\ファイル名 , quit 
			start /NODE 1 /B ...
			という/Bオプションを発見。
			cf. http://pf-j.sakura.ne.jp/program/dos/doscmd/start.htm

			Jenkinsがなんかleakしてるとかなんとか
			> Process leaked file descriptors. See http://wiki.jenkins-ci.org/display/JENKINS/Spawning+processes+from+build for more information
			うーん。startコマンドがforkみたいなことするから、file descriptorのleakとみなされてるのかな。厳しい。
			start /B /WAIT
			これが正しいのか？
			→　これでうまく動作した。難しすぎ。
		・とりあえず局面生成はJenkinsのjob化できた。
			ファイルの結合はDOSのcopyコマンドでいいか..そうか..。ならこれで完成か。
			copy /b a.bin + b.bin c.bin
			こんな魔法のような記法があるとは。
			copy /b *.bin all.bin
			これでいいか。そうか。

			ではこうか。
				start /B /WAIT /NODE %EXECUTOR_NUMBER% robocopy \\Ws2012_860c_yan\e\jenkins_container  c:\jenkins/container /s /mir
				cd c:\jenkins\container
				start /NODE %EXECUTOR_NUMBER% /B /WAIT exe\YaneuraOuV345.exe evaldir %EVAL_DIR% , threads 40 , hash 4096 , gensfen depth %DEPTH% loop %LOOP_MAX% file \\Ws2012_860c_yan\e\jenkins_output\%SFEN_FILE_NAME% , quit
			→できた(気がする)

			depth 6, 40HT 1億局面生成 = 9時間のようだ。
			80*9/24 = 30日かかるな。10プロセッサで3日か。そうか。
			もとい、1億局面、7時間ぐらいでいけそう。
			Jenkinsのjob、ひとつが4時間以内に収まるようにして、平均2時間の待ちで優先jobが実行されるぐらいにしておかないと
			TATが悪くてかなわん。長いjobと短いjobとアトランダムにあればマシか…。


	2) 学習をjob化
		・デプロイ、どうするべきか。
		→ robocopy組み合わせれば出来そう。事前にrobocopyすればいいだけか。

		・評価関数ファイルの保存フォルダ、別途指定できたほうが良いのでは。考える。
		→　Options("EvalSaveDir")用意したほうがいいかも。
		→　そうした。

		・jenkinsのjob、よほどのことがない限りキャンセルしないので、saveは1回でいいかも。
		→　5億学習ごとに1回とかの意味。まあいいや。ここがそんなに問題ではないだろうし。たぶん。
		→　とりあえず、1億局面に1回に変更。
		→　これで学習のjobを書けるはず…。

	3) 自己対局をjob化
		・pythonスクリプトの活用
		→　うーん。pythonすら要らないような気がしてきた。


・特定のjobと評価関数ファイルがバッティングしてはいけないので異なる評価関数ファイルは必ずフォルダを分けるべき..なのか..。そうか..。
	→　ちょっと仕組みを考える。
	・robocopyをしてネットワークドライブと同期させるスクリプトをJenkinsのjob化する。
		→　実行ファイルが重複してしまった場合は仕方がない。なるべくそれは起こらないようにするしかない。
		→　GitHubのprivate repositoryをfetchして、都度コンパイルすることは出来るのか…そうか…。
		やねうら王の公式のほうとごっちゃになるな…。
		Visual StudioのGitHubのplug-in使うのやめて、別で管理するしかないな…。うーむ..
		→　gitコマンドに慣れたほうがいいかも知れんな…。
		→　TortoiseGit導入した。
		→　GitHubから取ってくるのLAN内に大きなストレージがあるなら、いいアイデアではなさげだった。

	・save_eval()のフォルダ、設定できるようにする。
		→　した。


・Apery(WCSC26)から10億局面追加学習してそれと比較する。

			5G

			秒読み1000[ms]

			47.9%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#272
			やねうら王2016mid V344
			eval Apery20160722

			883-19-960(96.4% R-14.5)	


			秒読み100[ms]

			50.6%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#272
			やねうら王2016mid V344
			eval Apery20160722

			1677-32-1636(23.8% R4.3)	


			2G
			秒読み1000[ms]

			45.8%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#272
			やねうら王2016mid V344
			eval Apery20160722

			544-26-643(99.8% R-29.0)	


			1G

			秒読み1000[ms]

			43.9%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#272
			やねうら王2016mid V344
			eval Apery20160722

			235-11-300(99.8% R-42.4)	


			秒読み100[ms]

			50.2%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#272
			やねうら王2016mid V344
			eval Apery20160722

			1427-36-1416(41.8% R1.3)	


			秒読み100[ms]

			52.5%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#0
			やねうら王2016mid V344
			新基準(AperyWCSC26)

			735-7-665(3.1% R17.4)	


			秒読み1000[ms]

			53.8%	
			#282
			やねうら王2016mid V344
			eval AppendApery20160726
			#0
			やねうら王2016mid V344
			新基準(AperyWCSC26)

			477-8-409(1.0% R26.7)	



■ 2016/07/25

・そうか。Jenkins + 同時ビルド数=2にして、NUMA 0,1を必ず使うように強制できればいいのか。
	空いているほうのnumaを調べて、それをstartコマンドでそちらからタスクを起動できればいいのか。
	空いているほうのnumaを調べるのも、file lockか何かで済むのでは..
	global mutex使うか..。そうか…。
		launcher YaneuraOu.exe
	のようにしたときに空いてるほうのNUMAで実行してくれればいいだけか。そうか。

・Jenkinsインストール
	> java -jar jenkins.war

・CPU affinityの設定

	NUMA node番号は、startコマンドの/nodeオプションで指定できるようだ。(/affinity N ではない)
		start /node 0 YaneuraOu.exe


		0039Gから強くなってるとは言いがたいな。弱くもなってなさそうだけども。

		秒読み10000[ms]

		53.2%	
		#281
		やねうら王2016mid V344
		eval 179_0042G_V3
		#0
		やねうら王2016mid V344
		新基準(AperyWCSC26)

		885-40-777(0.4% R22.6)	

		10秒でこれだけしか変わらないのか…？


		秒読み500[ms]

		52.5%	
		#281
		やねうら王2016mid V344
		eval 179_0042G_V3
		#0
		やねうら王2016mid V344
		新基準(AperyWCSC26)

		480-7-435(6.4% R17.1)	


		秒読み500[ms]

		51.5%	
		#281
		やねうら王2016mid V344
		eval 179_0042G_V3
		#272
		やねうら王2016mid V344
		eval Apery20160722

		362-6-341(20.3% R10.4)	



		秒読み1000[ms]

		52.5%	
		#281
		やねうら王2016mid V344
		eval 179_0042G_V3
		#279
		やねうら王2016mid V344
		eval 179_0040G_V3

		622-12-563(4.3% R17.3)	
		1秒だと結構変わるような？
		10秒で回して、寝る。


		秒読み100[ms]

		50.0%	
		#281
		やねうら王2016mid V344
		eval 179_0042G_V3
		#279
		やねうら王2016mid V344
		eval 179_0040G_V3

		578-11-578(50.0% R0.0)	
		・10億局面に対してさらに2周まわしたが、変わらず


		秒読み100[ms]

		46.9%	
		#279
		やねうら王2016mid V344
		eval 179_0041G_V3
		#278
		やねうら王2016mid V344
		eval 179_0039G_V3

		559-10-634(98.5% R-21.9)	

	学習進めたら弱くなった。うーむ、そうか、やはり…。


		秒読み100[ms]

		50.2%	
		#279
		やねうら王2016mid V344
		eval 179_0040G_V3
		#278
		やねうら王2016mid V344
		eval 179_0039G_V3

		534-13-530(45.1% R1.3)	


179_0041G_V3
・よく考えたらSGDはcount集計しているからmini-batchのサイズで学習率変える必要ないわ。

・
1) 学習に使っているPC
2) 棋譜生成に使っているPC
3) 自己対局に使っているPC

	1)と3)を一緒にすると学習のmini batchの1回の処理が間に合わなくなって、勾配がおかしくなる。
	2)と3)をペアにして、1)とは隔離すべき。しかし1)に3)の処理が付随していて何とも。
	Jenkins導入するときに、このへんややこしいな…。
	1)と3)を同じPCでやるならプロセッサグループを指定すればいいのか…。うーむ。
	Jenkins入れて、かつ、プロセッサグループを管理する何かが必要だな。

	→　Jenkinsを使わなくて済む案を考えた。

	実行環境がフォルダ化されているとする。これをDockerのコンテナに相当するものだとみなす。
		container1/
		container2/
		container3/
	空いているプロセッサを見つけて、そのプロセッサに、コンテナ番号とタスク内容を割り振る。
	そのプロセッサは、ネットワークから、robocopyでlocal環境のなかにそのコンテナをコピーして実行する。
	実行結果は、robocopyで逆方向にsyncさせて終了…というのはどうだろうか。

	逆方向にsyncさせると共用したときに困るか。
	出力は別のフォルダがあるとすればいいのか。

		result/1
		result/2

	みたいな。
	ここに出力すると。

	これだけでいいなら、なんとなく出来そうな気はする。
	ログもそこに出力すればいいのか。うーん。そうか…。

	result一覧が表になっていて欲しいのだが。
	CSVファイルを別で生成するだとか？追記で済む方法がないものか..

	うーん。棋譜生成を4PCで回しておいて、自己対戦がしたいときはその負荷状態でいまの
	連続自己対戦フレームワークで行なって、学習だけ1PCで回すとちょうどよかったり？


・局面生成のときに評価値の打ち切り上限を3000にしたものを10億局面混ぜて学習を進めた。
	平均誤差(mean error)が215になってしまった。あらら？
	終盤のほうの評価値の絶対値の大きな局面だと誤差が大きくなるから、これは仕方ないのか…。
	
		179_0039G_V3

			秒読み100[ms]

			51.8%	
			#278
			やねうら王2016mid V344
			eval 179_0039G_V3
			#277
			やねうら王2016mid V344
			eval 179_0038G_CE

			1057-25-983(5.1% R12.6)	


			秒読み100[ms]

			49.5%	
			#278
			やねうら王2016mid V344
			eval 179_0039G_V3
			#272
			やねうら王2016mid V344
			eval Apery20160722

			619-8-631(63.3% R-3.3)	


			秒読み1000[ms]

			51.8%	
			#278
			やねうら王2016mid V344
			eval 179_0039G_V3
			#272
			やねうら王2016mid V344
			eval Apery20160722

			352-7-327(15.9% R12.8)	

		Apery20160722が+R50らしいので、ここに+R12
		おそらく+R65～R70程度に相当するのか？

			秒読み100[ms]

			55.4%	
			#278
			やねうら王2016mid V344
			eval 179_0039G_V3
			#0
			やねうら王2016mid V344
			新基準(Apery WCSC26)

			360-3-290(0.3% R37.6)
			

・学習のときに棋譜フォルダを指定するオプションをつけるか..
	learn dir XXX とか。
	あとloop回数かな。

	こんな感じ？
		log
		evalshare false
		threads 39
		learn bat 100 loop 3 dir \\Ws2012_860c_yan\e\genkif201607 kifu201607250800.bin kifu201607230600.bin kifu201607152200.bin kifu201607171700.bin kifu201607171800.bin kifu201607151400.bin


		log
		evalshare false
		threads 8
		learn bat 100 loop 3 dir \\Ws2012_860c_yan\e\genkif201607 kifu201607250800.bin kifu201607230600.bin kifu201607152200.bin kifu201607171700.bin kifu201607171800.bin kifu201607151400.bin

・棋譜、10億追加。(トータル65億程度？)

		log
		evalshare false
		threads 39
		learn bat 100 \\Ws2012_860c_yan\e\genkif201607\kifu201607250800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin


・評価値の打ち切り上限を無しにしたら、40HTで20万局面生成に50秒かかるようになってしまった。
	これはまずいかも…。以前は30秒だったはず…。


・究極的には評価関数は、search(N)をdepth Nでのsearchとして、
		qsearch = search(1) = search(2) = ... = search(n)
	となるべき。なので、いま
		qsearch = search(6)
	としているのは、
		qsearch = search(1) = search(6)
	のほうがいいはず。しかし学習時にsearch(1)の探索が必要になるので学習時間が増加する。
	どうしたものか…。現状の方法で頭打ちになるまでは頑張ってみるか…。


・損失関数、交差エントロピーと勝率とで比較。ただし勝率のほうはあまりiteration回せなかった。
	交差エントロピーのほうはSGDで3Mのmini-batchにした。
	rmseは下がってないのに多少強くなっているようだ。

	次回の方針
	・SGDは勾配が出にくいとおかしくなるのでmini-batchのサイズを大きくしてみる。
	・局面数100億ぐらいまで増やしてみる。
	・SGDでもいいからきちんと回す。
	・探索深さ深くして教師を使ってみる。
	・VALUE_MAX_EVALまで生成した局面データにしてみる。

			秒読み100[ms]

			53.2%	
			#277
			やねうら王2016mid V344
			eval 179_0038G_CE
			#276
			やねうら王2016mid V344
			eval 179_0034G_WIN

			1048-22-922(0.2% R22.3)	

		新Apery

			秒読み100[ms]

			52.3%	
			#277
			やねうら王2016mid V344
			eval 179_0038G_CE
			#272
			やねうら王2016mid V344
			eval Apery20160722

			916-12-835(2.6% R16.1)	


			秒読み1000[ms]

			47.8%	
			#277
			やねうら王2016mid V344
			eval 179_0038G_CE
			#272
			やねうら王2016mid V344
			eval Apery20160722

			752-12-822(96.1% R-15.5)	


		旧Apery

			秒読み100[ms]

			52.1%	
			#277
			やねうら王2016mid V344
			eval 179_0038G_CE
			#266
			やねうら王2016mid V344
			新基準

			1221-17-1124(2.3% R14.4)	


			秒読み1000[ms]

			51.9%	
			#277
			やねうら王2016mid V344
			eval 179_0038G_CE
			#266
			やねうら王2016mid V344
			新基準

			451-5-418(12.4% R13.2)	
		

・Adamの定数、static constexpr LearnFloatTypeに変更。

・SGDのパラメーターもlearn.hではなく、自動的に計算して設定するように変更。

	SGDで3Mぐらいの単位で回すとさらに損失関数の値は下がる。
	SGDが一番、統御しやすいという意味はあるのか…。


・棋譜生成、評価値上限、VALUE_MAX_EVALに変更してみる。

・learnコマンドでbatchサイズ指定できるようにする。

		log
		threads 8
		evalshare false
		learn bat 100 \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin

		log
		threads 8
		evalshare false
		learn bat 500 \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin
		→　これで改善するかしばらく回してみる。

		mini-batchサイズを上げると学習率を下げないと辻褄が合わないのかも…。うむむ…。

		学習率5.0f→1.0fにしたもので比較。うーん..よくわからん。


・YaneGrad、LOSS_FUNCTION_IS_WINNING_PERCENTAGEにするときは、学習率を変更するようにした。

		// 学習率η
#if defined (LOSS_FUNCTION_IS_CROSS_ENTOROPY)
		const LearnFloatType eta = 5.0f;
#elif defined (LOSS_FUNCTION_IS_WINNING_PERCENTAGE)
		const LearnFloatType eta = 20.0f;
		// 少し大きめに
#endif

	4倍しておく。

・learnコマンド使ったときに更新式を表示するようにしよう。
	→　した。

・Adamおかしい。損失関数減らない。

	const double eta = double(32)/64.0
	const double epsilon = 10e-8
		がゼロになってた。禿げそう。
	class内のconst doubleまわりの最適化、何か怪しげ。
	しかもクラス外から参照できない糞仕様。static constexprにするか..
	→　全部defineにしてやったら直った。
	→　Adamの更新式、結構きわどいので更新式の中身だけdoubleにして計算しておく。
	→　Adamめっちゃ遅い…。g == 0のところも更新しているからか。うーん。
	結果的にmini batchのサイズが大きくなって、かえってよかったり？


・学習のときにepochの初期化忘れていたの修正。
	→　問題はこれだけではないようだ…。

・Adam、wがゼロベクトルから損失関数が下がること自体は確認できた。

・Adam、更新に時間がかかるので、あまりよろしくなかった。
	1) doubleの計算精度
	2) sqrt 2回
	3) 途中計算ややこしい
	4) gがゼロでも更新必要(もしかすると不要？)
	特に4)が遅くなる要因。sparse性が生きてない感じ。

	結論的にはAdaGradのほうが良いのではという感じ。

・Adamで30億局面追加学習させた。

		秒読み100[ms]

		50.8%	
		#275
		やねうら王2016mid V344
		eval 179_0033G
		#0
		やねうら王2016mid V344
		新基準

		637-10-618(29.6% R5.3)	


		秒読み100[ms]

		50.6%	
		#275
		やねうら王2016mid V344
		eval 179_0033G
		#274
		やねうら王2016mid V344
		eval 180_0030G

		720-6-703(32.6% R4.2)	

		ひとつ前のバージョンに対してR3,4ぐらい強くなっているかも、という程度。

・目的関数、変更してAdaGradで追加学習させてみる。
	learnのときに目的関数を表示したほうがいいかも？


■ 2016/07/24

・定跡のバイナリサーチ、バグってた
	https://twitter.com/merom686/status/756746338268618752
	e - 40 < sは、eが無符号型だとまずいのか。修正した。


・AdaGradの更新式、1箇所にまとめられないのか？
	→　できそう。
	→　1箇所にまとめられた。よしよし。
	そしてKK配列のlimit、緩和する。

		//#undef YANE_GRAD_ALPHA
		//#define YANE_GRAD_ALPHA 0.99f
		//#undef YANE_GRAD_ETA
		//#define YANE_GRAD_ETA 5.0f
		//#undef YANE_GRAD_EPSILON
		//#define YANE_GRAD_EPSILON 1.0f
	→　この定数、defineで定義するのやめる。

・Adam書けた。

		log
		threads 8
		evalshare false
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin

		→　学習率調整し忘れていた。とりあえずFV_SCALE/64にした。

・新Apery評価関数(20160722) vs 旧Aperyの評価関数     : 943-19-795(R29.7) 1手1秒相当
・新Apery評価関数(20160722) vs やねうら王(181_0020G) : 547-7-461(R29.7)	1手1秒相当
	だそうな。


		秒読み2000[ms]

		50.5%	
		#273
		やねうら王2016mid V341b
		eval 181_0024G
		#0
		やねうら王2016mid V341b2
		新基準

		143-3-140(40.6% R3.7)	

		これでもまだApery(WCSC26)と互角ぐらいか。

・そうか。評価関数のMutex名、USI Optionで指定できるといいのかな。そうすれば同じバージョン同士でも
	　共有メモリを使って対戦できるわけで…。あるいは、フォルダ名をそのままmutex名にするだとか。
	 バックスラッシュがmutexに使えないのか。うーん、この..。仕方ないな。

・learnコマンドのために置換表をオフにしている場合、起動時にメッセージが出たほうが良いな。
　これで間違えて棋譜を生成してはかなわん。

・gensfen、最適化したけどあまり速くならん。評価値3000まで出力するようにすると、終盤だからdepth 6に
　要する時間が相対的に増加するということなのか。そうか…。

・53億局面でもう少し学習を回してみる。

		log
		threads 39
		evalshare false
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607230600.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin

・batch型連続自己対局が出来ないと不便だな…。
・自己対戦フレームワーク、対局回数を指定してその回数だけフルスレッドでぶん回してくれたほうが嬉しい。
	→　この２つ、あとで書くか…。


■ 2016/07/23

・とりあえず、これでおおむね作業終了。


・やねうら王V3.43から、同時に起動している同じバージョンのやねうら王同士で評価関数を共有するようになりました。
	(こうすることで100個同時に起動しても置換表サイズ＋αぐらいのサイズしか消費しないというメリットがあります。)
	その代わり、評価関数ファイルを変えた自己対戦は出来なくなります。(異なるバージョンのやねうら王を用いれば出来ます)
	このへん、オプション設定で共有をオフにする機能をつけるか考え中です。

	→　オプションで設定できたほうがいいような気がしてきた。
	→　この機能追加した。


・40億局面だとまだ足りてない感。
	→　もう20億ほど生成してから考えるか…。

・評価関数ファイルを20種類ぐらい公開する準備。
	→　28バリエーション公開した。

・ネットワーク上の局面ファイルからの読み込みが遅いの改善できるかも。
	全スレッドがI/O待ちになるのがイケてなくて、読み込みバッファの残りが少なくなったら
	先行して読みに行っておくべきなのでは。
	→　ファイル読み込み専用スレッドを起動して、読み込んでつねに充填しておくぐらいのことをしないとダメか..
	→　うまく書けた…気がする。

		log
		threads 40
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin

		→　10万局面に対して4,5秒だったのが7秒かかるようになったけど、前よりはマシか。
			許せる範囲と言えば許せる範囲なのかも。うーん。やはり、もったいない気もするのでSSD使うか…。
		→　sleep(1)に変えたら6秒になった。ほぼ変わらず。というか、SSDからが逆に6秒になってしまった。
			workerの書き方がよろしくないか？
		→　これはこれでいいや。
		→　4CHT8だと17秒、20CHT40で7秒は悪すぎ…。どうなってんの…。
		→　340MBのrandom shuffleが遅い可能性も..うーん、どうなんだろ。
			hotspot調べてみる。
		→　調べるまでもなく、lockしてのmemcpyとか筋が悪すぎるな。あれ全部やめよう。
		→　書き換えた。めっちゃシンプルになった。これで動いてくれれば。
		→　デバッグ完了。
		→　40HTで100万局面、4秒程度になった！速い！やったー！


・AdaGradで一度目にrmse上がるのおかしすぎ。何かバグがある予感。

				if (abs(w.g[0] > 100))
				{
					cout << endl << k1 << k2;
					cout << endl << w.g[0] << " , " << w.g[1] << " | " << w.g2[0] << "," << w.g2[1];
				}

		w.g[0]、一回目300とかつくんだな。こりゃいかんわ。
		SGDでもこんなに大きな値が来るとたまらん気はする。
		AdaGrad、最初のiteration 3回ぐらいはupdateを保留するか。

		→　AdaGradとYaneGrad、3回目ぐらいまではg2のupdateのみにするようにした。
		→　しかしあまり意味がなかった…。
		→　5回に変更。

・sfenのgeneratorもI/Oまわりの並列化、きちんと出来る気がしてきた…。
		→　計算したところ、しても速度的に改善しなさそうなのでこれでいいや。

・コンソール出力が詰まる問題、コマンドプロンプトの出来がよくないんだろうな…。
	他のコンソールエミュレーターを試してみる。
	http://conemu.github.io/
	→　あかん。余計悪かった。
	→　powershellのほうがなんぼかマシ。

・学習モードでの出力をもっと抑制するモードをつけないとまずいな。あとファイルをエンドレスに読み込むモードと。
　あとで考えよう…。
	→　抑制機能つけた。
	→　2周回したいなら同じファイル名 2回書けばいいか。そうか。

・最後まで回すと落ちた。
	rmse = 0.0789076 , mean_error = 181.632
	file_worker_threadのjoin()書いてないからか。そうか。


■ 2016/07/22

・ゼロパラメーターから学習させた評価関数パラメーターについて。

 →Xeon Dualで自己対戦させたときに子プロセスの属するプロセッサグループはランダムのようだ。
 　自動的にバラける。これは便利。1PCで並列80対局、できる。これはすごい…。


 	181_0020G
		秒読み200[ms]

		46.2%	
		#271
		やねうら王2016mid V341b
		eval 181_0020G
		#0
		やねうら王2016mid V341b2
		新基準

		423-4-493(99.1% R-26.6)	

		不思議なことに長い時間においては互角ぐらいっぽい。ふーん..

		秒読み2000[ms]

		50.2%	
		#271
		やねうら王2016mid V341b
		eval 181_0020G
		#0
		やねうら王2016mid V341b2
		新基準

		146-2-145(45.3% R1.2)	


	182_0018G

		秒読み200[ms]

		46.9%	
		#271
		やねうら王2016mid V341b
		eval 182_0018G
		#0
		やねうら王2016mid V341b2
		新基準

		336-1-381(95.7% R-21.8)	


	190_0013G

		秒読み300[ms]

		44.9%	
		#271
		やねうら王2016mid V341b
		eval 190_0013G
		#0
		やねうら王2016mid V341b2
		新基準

		269-6-330(99.4% R-35.5)	


		秒読み5000[ms]

		44.5%	
		#271
		やねうら王2016mid V341b
		eval 190_0013G
		#0
		やねうら王2016mid V341b2
		新基準

		175-6-218(98.7% R-38.2)	


	200_0011G

		秒読み1000[ms]

		43.6%	
		#271
		やねうら王2016mid V341b
		eval 200_0011G
		#0
		やねうら王2016mid V341b2
		新基準

		184-1-238(99.6% R-44.7)	

		
		秒読み5000[ms]

		37.8%	
		#271
		やねうら王2016mid V341b
		eval 200_0011G
		#0
		やねうら王2016mid V341b2
		新基準

		93-1-153(100.0% R-86.5)	



	 222_0010G

		秒読み1000[ms]

		43.8%	
		#270
		やねうら王2016mid V341b
		eval 222_0010G
		#0
		やねうら王2016mid V341b2
		新基準

		141-1-181(98.9% R-43.4)	

		長い時間においてはそこそこ強いっぽい？
		序盤の形の理解において優れているのかも。


	さらに40億局面ほど回してみた。弱くはなってなさげ。もう少し回す。

		秒読み100[ms]

		41.9%	
		#270
		やねうら王2016mid V341b
		eval 223_9000M
		#0
		やねうら王2016mid V341b2
		新基準

		373-6-518(100.0% R-57.0)	


		秒読み1000[ms]

		41.5%	
		#270
		やねうら王2016mid V341b
		eval 223_9000M
		#0
		やねうら王2016mid V341b2
		新基準

		211-2-298(100.0% R-60.0)	


	損失関数の値は悪化したが、過学習ではなさげ。

	225_8000M

		秒読み1000[ms]

		37.2%	
		#269
		やねうら王2016mid V341b
		eval 225_6000M
		#0
		やねうら王2016mid V341b2
		新基準

		129-3-218(100.0% R-91.1)	


		秒読み100[ms]

		38.5%	
		#269
		やねうら王2016mid V341b
		eval 225_6000M
		#0
		やねうら王2016mid V341b2
		新基準

		380-9-607(100.0% R-81.4)	



	220_4033M

		秒読み100[ms]

		27.6%	
		#268
		やねうら王2016mid V341b
		eval 220_4033M
		#0
		やねうら王2016mid V341b2
		新基準

		249-6-652(100.0% R-167.2)	


		秒読み500[ms]

		27.5%	
		#268
		やねうら王2016mid V341b
		eval 220_4033M
		#0
		やねうら王2016mid V341b2
		新基準

		82-0-216(100.0% R-168.3)	



	255_3680M

		秒読み100[ms]

		30.2%	
		#267
		やねうら王2016mid V341b
		eval 255_3680M
		#266
		やねうら王2016mid V341b2
		新基準

		163-0-376(100.0% R-145.2)	


		秒読み500[ms]

		25.5%	
		#267
		やねうら王2016mid V341b
		eval 255_3680M
		#266
		やねうら王2016mid V341b2
		新基準

		48-0-140(100.0% R-186.0)	


		秒読み1000[ms]

		25.9%	
		#267
		やねうら王2016mid V341b
		eval 255_3680M
		#266
		やねうら王2016mid V341b2
		新基準

		41-1-117(100.0% R-182.2)	

・学習時に置換表オフに出来たほうが良いのでは..
	→　learn.hに書けるようにした。

・mini-batchサイズをlearn.hに書けるようにした。



■　2016/07/21

・40コアでテスト

	network上のファイルだとそこがボトルネックになるのか？
	→　ちょっとマシになったがやはり遅い。
	→　sfenのunpackとかがボトルネックになっている。
	うわぁぁぁ。

	Position::sfen()、stream使わないようにして書き直すか…。
	→　高速化した。

	HT8コアで100万局面が25秒→17秒に短縮した。

		log
		threads 40
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin

	HT40でSSD上なら100万局面4,5秒。ネットワーク上のHDDだと15秒ぐらい。何も速くなってないな。これは参った…。
	もう少し大きなSSD買おう…。そうしよう…。

	SGDとAdaGrad 10億局面ほど回して比較。

	SGD 196.983
	AdaGrad 196.329
	↓ ここから再開して20億局面
	SGD 200超えた
	AdaGrad 210超えた
	発散してる感じ？

・手番クリアして、手番のgrad=0にして誤差がどれだけ下がるかテスト。
	スタート時点で227。7ぐらい高いのか。これが195ぐらいに下がってくれればKPP手番は不要かも。
	rmse = 0.094付近から。確かにrmse少し高いな。

	→　発散した。手番消している分、eta半分にしないと辻褄が合わないのか。そうか…。再チャレンジ。
	→　突然発散するの、どこかがオーバーフローしているからでは…。

	eta、1/4にしてSGDで再開。


・手番の値を動かすの、η2 = η/4とかでいいのでは..。
・評価関数パラメーターの各値にリミットをかける。

	INT16_MAX/2 ≒ 8096 , FV_SCALEで割って256。
	　KPPの位置評価、そんなに大きな値になるのはおかしいのでは。


						ASSERT_LV3(abs(kk[k1][k2][0]) < INT16_MAX / 2);
						ASSERT_LV3(abs(kk[k1][k2][1]) < INT16_MAX / 2);
				
		#if ASSERT_LV < 3
						// 絶対値を抑制する。
						SET_A_LIMIT_TO(kk[k1][k2],INT16_MIN/2,INT16_MAX / 2);
		#endif

	→　これassertで書くのやめて、この制限は必ずしておくことにする。

・AdaGradに最初のほうの更新量を抑制するε項を追加。

				// AdaGradにおいて最初のほうのiterationでは値を動かさない。
				if (w.g2[0] < 0.01f || w.g2[1] < 0.01f)
						goto NEXT_KK;

			→　これやめて、epsilon項を追加するように変更。

・AdaGradが発散するはずがなかった。kkpだけ更新式間違えてた。
	→　うまく学習できるようになった。

・ゼロパラメーターからの学習、再挑戦。

・AdaGradのη、再調整。
	eta =  2.0  , ε=10 , mean_error = 212.141　→　207.130(1000万局面)
	eta =  5.0  , ε=10 , mean_error = 213.765  →  206.951(1000万局面)
	eta =  5.0  , ε= 5 , mean_error = 214.090  →  206.897(1000万局面)
	eta =  6.0  , ε= 3 , mean_error = 215.484  →  207.038(1000万局面)
	eta =  7.0  , ε= 1 , mean_error = 217.741  →  208.684(1000万局面)
	eta = 10.0  , ε= 1 , mean_error = 225.195  →  215.708(1000万局面)

	発散しないなら大きな値から開始したほうが気分がいいのでは。

		log
		threads 8
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin

・手番なし、mean_error = 201から下がらない。(10億局面あたりでサチった模様)

	AdaGrad、g2が大きくなってくるとそのパラメーター移動させられなくなるので他のパラメーターが遅れて追随してきてもどうしようもないという意味はあるのでは。
	　g2の条件、制限しておくほうが無難なような気も。しかし、そこをゆるやかに減衰させていくとAdamになるのか…。うーん。

	→　g2 *= 0.999; みたいな式を入れると、どこかで律速するのでこういうのを入れるべきかも知れない。

・
		log
		threads 40
		learn ..\YaneuraOu2016Engine\genkif\kifu201607171700.bin ..\YaneuraOu2016Engine\genkif\kifu201607151400.bin ..\YaneuraOu2016Engine\genkif\kifu201607171800.bin ..\YaneuraOu2016Engine\genkif\kifu201607152200.bin



■　2016/07/20

・AdaGradうまく動くようになったので一晩回してみる。
	→　なんかおかしい。やりなおし。

	やりすぎであったか…。
-				if (w.g2[0] < 1000.0f || w.g2[1] < 1000.0f)
+				if (w.g2[0] < 0.01f || w.g2[1] < 0.01f)
	→　やはり原因はこれだったみたいだ。

		log
		threads 8
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin

		1000万局面での学習率の調整。

		eta = 2
			mean_error = 213.334 → 206.672

		eta = 2.5
			mean_error = 218.201 → 210.661

		eta = 5
			mean_error = 219.022 → 224.263 → 208.294

		eta = 10
			mean_error = 247.432 → 285.383 → 233.979

		// 乱数を固定化して200万局面

		eta = 1.7
			mean_error = 212.212 → 209.221
		eta = 1.8
			mean_error = 212.261 → 209.029
		eta = 1.9
			mean_error = 212.206 → 209.723
		eta = 2.0
			mean_error = 212.515 → 209.497
		eta = 2.1
			mean_error = 212.969 → 209.951

		このテスト自動化して1億局面ぐらいのところで比較すべき。

・交差エントロピーも試す。

		eta = 1.8 , cross entropy
			mean_error = 212.221 →　208.536(200万局面) →　206.486(1000万局面)

		eta = 2.0 , cross entropy
			mean_error = 213.109 →　208.993(200万局面) →　205.895(1000万局面)

		eta = 2.2 , cross entropy
			mean_error = 213.417 →　209.231(200万局面) →　206.037(1000万局面)

・評価関数ファイルの定期的な保存、もう少し何か考える。(べき)
	 10億局面ごとにファイル名を変更して保存するなどしたほうが良いのでは…。
	 →　変更した。

・AdaGrad、中断するときにg2の配列を保存しておかないと再開できないのでは…。まあいいか…。
	AdaGradのほうがSGDよりいい値に行くんだろうけど、いまひとつ…。

	SGDをadaptiveにしたほうがいいのではなかろうか。

	しかしAdaGradは、mini-batchにしなくてもうまくいくのかも？うむむ？

・ゼロベクトルから学習させたやつ、R2000程度は余裕でありそう。うーん、そうなのか…。


■　2016/07/19

・ミラー、よく考える。
	→　実装した。
	→　ミラー、なんかおかしい。やめよう。

・評価関数、ゼロパラメーターから学習できるのかテスト。

	rmse = 0.190385 // zero vector
	rmse = 0.170538 // 1000万局面
	rmse = 0.163090 // 2000万局面。

	そこそこいけるかも？

・評価関数パラメーターの保存ルーチン書く。
→　書けた。

・ゼロベクターから学習させてみる。

	45億ほど。

		log
		threads 8
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin

	8HT、25秒で100万局面。4.5G * 25 / 1M = 4500 * 25 = 112,500秒。1.5日ぐらいで終わる感じ？

	rmse = 0.194836 , mean_error = 490.541 //	開始時。
		0ベクトルだと490も差があるのか…。
		たぶん0.01ぐらいになると以前の評価関数と同じぐらい。
		ゼロから棋譜生成して学習を繰り返してもいいぐらいだな…。
	rmse = 0.155197 , mean_error = 373.743  //  1億
	rmse = 0.151064 , mean_error = 360.2    //  2億
	rmse = 0.149133 , mean_error = 352.575  //  3億
	rmse = 0.150657 , mean_error = 353.563  //  4億
	rmse = 0.14781 , mean_error = 341.956   // 10億

	この速度だと80億やっても..。

	rmse = 0.0966129 , mean_error = 226.607 // 再起動するとなぜかだいぶ減ってる。なんで？
	// 置換表に値が残っていて下がっていないように見えていたのかも。rmseの計算前に置換表の世代進めたほうが良いのでは。
	
	棋譜の順番入れ替えて再開。
		log
		threads 8
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607171800.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607152200.bin \\Ws2012_860c_yan\e\genkif201607\kifu201607171700.bin
	
	ここから8億回したがmse上がった。qsearch()の結果に対して強化学習するのがいけないんだろうな。

	qsearch()の結果ではなくevaluate()に対して強化学習するか。
	↓
	何も下がらない。なんで？

	学習オプションを一箇所にまとめたほうが良いのでは…。
	→　まとめた。

	evaluate()で下がらないのはSGDのほう間違いなく何かバグってる。
	count少ないときには勾配出てないから値は動かさないほうが良いのでは。

	evaluateのほう、損失関数下がるようになった。ifdefどこか名前間違ってたっぽい。


・Weight配列、型指定間違っていたので修正して、ゼロベクターからの学習再開。
	→　と思ったら問題なかった。

・256手付近でmax_plyのためleafが辿れないのまずいかも。

	-    for (ply = 0; ply < MAX_PLY; ++ply)
	+    for (ply = 0; ply < MAX_PLY - 16; ++ply)

	棋譜生成のときに16手前までにしとくか…。


■　2016/07/18

・AdaGradで学習する部分書けた。次元下げまだだけど。

		threads 8
		learn \\Ws2012_860c_yan\e\genkif201607\kifu201607151400.bin

	100万局面 17秒/8スレッド。
	40スレッドで17/5秒。80億局面で8000倍 = 27200秒。1周7.55時間。

・SGDで
	rmse = 0.09053
	rmse = 0.08677 // 1000万局面
	rmse = 0.08520 // 2000万局面
	// rmse下がった!!

	↓kpp次元下げあり。
	rmse = 0.0897942
	rmse = 0.0866647 // 1000万局面
	rmse = 0.0862505 // 2000万局面
	rmse = 0.0861872 // 3000万局面

	// ミラーなしで、p1,p2の入れ替えだけあり。
	rmse = 0.0898962
	rmse = 0.0870459 // 1000万局面
	rmse = 0.0866125 // 2000万局面
	rmse = 0.0863849 // 3000万局面

	// ミラーは入れておくか。
	
・AdaGradで
	rmse = 0.0907107
	rmse = ...
	// 最初の数回ぐらい、むしろ上がるのか。そうか。
	// この調整難しいな。updateに時間がかかるというのもあるし…。

	SGDでがんばろう。


■　2016/07/17

・生成された80億局面のファイルの読み込み例

	while (!fs.eof())
	{
		u8 data[34];
		fs.read((char*)data, 34);

		auto sfen = pos.sfen_unpack(data);
		pos.set(sfen);

		// 評価値は棋譜生成のときに、この34バイトの末尾2バイトに埋めてある。
		Value value = (Value)*(int16_t*)&data[32];

		cout << pos << value << endl;
	}

・learnのスレッド並列で局面ファイルを読み込むルーチン、少し書いた。


#if 1
	{
		fstream fs;
		fs.open("a.bin", ios::binary | ios::in);

		PackedSfenValue p[10000];
		while (fs.read((char*)&p, sizeof(PackedSfenValue)*10000))
		{
			for (int i = 0; i < 10000; ++i)
			{
				auto q = p[i];
				auto sfen = pos.sfen_unpack(q.data);
				pos.set(sfen);
			}
			cout << '.';
		}
		return;
	}
#endif

・learnコマンド少し実装。packed sfenファイルの読み込みとshuffle～unpackのコードは書けた。

	あとは、棋譜分離してmse計算する部分と、AdaGradか何かで値動かす部分か…。

・mseを計算するルーチン書けた。
	→　初回だけ表示おかしい。デバッグすべき。
	→　二回目以降、置換表にhitするからか。そうか…。



■　2016/07/16

・ai5さんいわく、USI原案によると手駒の表記は、飛・角・金・銀・桂・香・歩の順らしい。

	Wayback Machine
	https://web.archive.org/web/20080131070731/http://www.glaurungchess.com/shogi/usi.html

	> The pieces are always listed in the order rook, bishop, gold, silver, knight, lance, pawn;

	ai5さんのおっしゃる通りのようです。将棋所の作者が将棋所で実装するときに削ったようですね。
	せっかく原案のほうはsfen文字列が一意に定まるようになっていたというのに…。いまのうちに思考エンジン側も
	出力はこれに倣うべきかも知れませんね。このあと禍根を残さないためにも…。

・上の内容に伴い、Position::sfen()を修正。

			const Piece USI_Hand[7] = { ROOK,BISHOP,GOLD,SILVER,KNIGHT,LANCE,PAWN };
			auto p = USI_Hand[pn];

・makebook sortコマンドを実行したときにsfen文字列を再構築するように変更する。



■ 2016/07/15

・sfenの手駒の表記の揺れを補整するために、makebook sortコマンドのときに
　一度sfen()から局面を作ってそれを書き出すようにすることで、やねうら王定跡フォーマットで
　使っているsfen文字列化したほうがよさげ。

	https://twitter.com/merom686/status/753406922414432259
		SFENで先手の持ち駒が角金歩のときの表記。
		BGP : ShogiGUI, 局面ペディア
		PGB : Blunder.Converter
		PBG : やねうら王定跡フォーマット2016

	→　うーん。逆に、やねうら王定跡フォーマット2016では手駒のところは、PLKSBRGの順であるものとしよう。

・ShogiGUIの検討モードで定跡DBにhitしたときの表示、思考エンジン側でどうするのがベストなのかよくわからない。

	→　ShogiGUIの掲示板で質問しておく。

		ShogiGUIの検討モードで、ShogiGUI側の定跡を用いない設定で検討させているときに、
		思考エンジン側の定跡にhitしたときに、思考エンジン側は複数の候補手が定跡に登録されているのでこれを通常の思考を返すときのように" multipv 1 "のようにして返したいのですが、しかしそうすると、ShogiGUI側で候補手3手のようにしていると" multipv 3"の指し手までしか検討ウィンドウに表示されないように思います。

		ユーザーにとってはおそらく思考エンジン側の定跡DBにhitしている以上、そのすべてが表示されて欲しい気がするのですが、だからと言って「候補手10手」のようにしていると、定跡にhitしない局面でMultiPV = 10で思考してしまうため、ユーザーはこの設定を変えるために定跡にhitするごとに、「候補手3手」と「候補手10手」とを切り替えながら検討することになって、なんともユーザビリティが悪いように思うのです。

		「候補手3手」の状態であっても" multipv 4"以降の指し手も検討ウィンドウに表示されるような仕様にしては何かまずいのでしょうか。あるいは思考エンジン側で何か出来ることがあれば教えていただければと。

	→　ShogiGUIの作者、対応するとのこと。助かる。


■ 2016/07/14

・mirror_write()絡み、何かバグがあるらしい。あとで調査。
	→　バグ修正した。

・Apery(WCSC26)の評価関数バイナリ側の問題もあったのでAperyのGitHubで報告しておいた。

	https://github.com/HiraokaTakuya/apery/issues/7

		Apery(WCSC26)の評価関数ファイルについて。

		問題点1) kppテーブルなのですがkpp[k][p1][p2]に対して、p1==0 もしくは p2==0のときに、値がゼロにならない。(ゴミが入っている)

		駒落ちのとき、BonaPiece == 0としたいので、ここにゴミが入っていると駒落ちでの局面評価がおかしくなります。ここ、ゼロで埋めていただけないでしょうか。kkpテーブルも同様にkkp[k1][k2][0]に対してゴミが入っています。

		問題点2) kkpテーブルのkkp[k1][k2][p]に対して、p == e_hand_pawn-1のような0枚目の手駒に対する値が0になっていない。

		実際にはこの要素は参照しませんが、ここにゴミが入っていると、assert(kkp[k1][k2][p][0] == -kkp[~k2][~k1][~p][0]);のようなassertが通らなくなってしまいます。(Squareに対して~sqは180度回転した升を返す演算子、BonaPieceに対して~pは(盤上の駒であれば180度回転させ)、相手の駒にする演算子だとします。)

		問題点3) kpp[k1][p1][p2] != kpp[k1][mirror(p1)][mirror(p2)] ただし、file_of(k1) == FILE_5

		玉が5筋にいるときに、kppの要素が左右のミラーに対して対称性がありません。玉が5筋以外にいるときは対称性があるので学習上の何らかのバグでノイズを入れてしまっているのではないかと思います。当然ながら、ここは対称にしたほうが棋力的にも強くなるのではないかと思います。

		例) kpp[SQ_51][f_hand_pawn][f_pawn + SQ_12] != kpp[SQ_51][f_hand_pawn][f_pawn + SQ_92]
		※　玉が51にいて、「先手の手駒の1枚目の歩」と、「盤上の12の歩」というkpp値が、この12の歩を92に移動させたときのものと同じ値でないといけないはずなのに、そうはなっていません。

		急ぎませんので、次回、評価関数バイナリを公開されるときにでも直っていれば嬉しいです。


■ 2016/07/12

・深さ8で1億局面ほど作ってみる。
threads 40
hash 4096
gensfen 8
→　HT40で3分で20万局面。
→　1日9600万局面程度作れそう。HT80で2億。5台で10億。8日で80億。
　そこそこ作れるような？
→　棋譜生成中に落ちた。原因不明。ASSERT有効にしてVisual Studio入れてデバッグするか…。
→　このあと棋譜生成のPCでしばらく回しておく。

・定跡作ってるの、最後の1 nodeが20時間かけたのに保存されてなかった。禿げそう。
　まあいいや…。

→　原因わかった。threadの終了フラグは立っていても、joinせずに抜けているので、
 threadのstack破壊しているようだった。修正した。

・深さ6で80億作ってみる。
	threads 40
	hash 4096
	gensfen 6
	→　HT40で30秒で20万局面。6倍速いので..。HT80で12億/日。

・mirror_write()絡み、何かバグがあるらしい。あとで調査。

・動作テストしてリリース。

	bookfile yaneura_book1.db
	bookonthefly true
	isready
	go


■ 2016/07/11

・てか、compute evalのタイミングでis_ready()呼び出しても良いのでは…。
　→　まあいいや。これやりだすとしんどい(気がする)

・スレッドごとに別の局面を探索させるときにhistoryみたいなglobalテーブル持っていると
　まずい気がしてきた。

・定跡生成中に保存できなくてそのまま思考だけ進むことがあるの、本当に謎。
        if (loop_count == loop_max)
		この条件先に満たしてしまうのか…。
		  cout << "waiting for all workers" << endl;
		最後にcallback一回必要なんだな。修正した。

・やねうら大定跡、今日中に生成終わりそう。
　もう少し追加で回しておくか…。


■ 2016/07/10

・shared memoryを用いた評価関数パラメーターの複数プロセス間共有。

	実装した。遅くはないようだ、メモリ節約にはならない模様。

	===========================
	Total time (ms) : 491304
	Nodes searched  : 341103366
	Nodes/second    : 694281

	↑あれ？探索node数が異なる…。配列をポインタにしたときに正しく互換性が保てていないのか…。そうか…。

	===========================
	Total time (ms) : 108695
	Nodes searched  : 68270869
	Nodes/second    : 628095

	shared memory版
	===========================
	Total time (ms) : 102153
	Nodes searched  : 68270869
	Nodes/second    : 668319
	→　完全に一致した。

	isreadyコマンドを入力してからbenchコマンドを叩くと少しnpsが高く出るようだ。
	理由はよくわからないが、評価関数の読み込みから時間をあけて十分CPU負荷が下がってからbenchコマンドを叩いているからか。

・shared memoryでsystem memoryの使用量が減らない問題

	CreateFileMapping, MapViewOfFile, how to avoid holding up the system memory
	http://stackoverflow.com/questions/1880714/createfilemapping-mapviewoffile-how-to-avoid-holding-up-the-system-memory

	VirtualFree on shared memory
	https://groups.google.com/forum/#!topic/microsoft.public.win32.programmer.kernel/3SvznY38SSc

	SEC_RESERVEを指定して確保したあとVirtualUnlockするというhackが書いてある。
	→　pagingされていたものが開放されるが、そのあとアクセスしないことが前提なのか…。

・共有メモリを用いて、メモリ使用量が減らない問題、解決した。
　ベンチマークコマンドがデフォルトで1GB確保しているだけだった。
　共有自体、うまく行っていた。

　あと、npsが上がらない問題も、置換表を16MBだとnps出た。1024MBだと10%ぐらいダウンした。
　なるほど。そういうことか…。


■ 2016/07/09

] V3.33

・やねうら大定跡のような大きなファイルを扱う場合は、packed sfenにして、
	メモリに丸読みせずに1手指すごとにバイナリサーチするような実装もあったほうがいいのかも。
	いや、packed sfenにせずともバイナリサーチは出来るか。そうか…。
	テキストファイルのバイナリサーチ、コード、結構ややこしい気がしなくもないが…。

		BookOnTheFly    : 定跡ファイルをメモリに丸読みしない
		
		やねうら大定跡のような巨大な定跡を試合開始時に読み込まれるとその読み込みに時間がかかるため、
		対局中、1手指すごとにファイルを読みに行くオプション。

	うーん。書き出しのときにsfen文字列でsortされている必要性が出てくるな…。
	これ、定跡フォーマットがそのことを保証していないので、意外と面倒だな。
	読み込みのときのparseを並列化するだとか？

	やはり、packed sfenにして、そちらはsortしておき、バイナリサーチで調べられるように実装すべきかな…。
	もうちょっと定跡ファイルが大きくなってきて気が向いたらやろう。

	てかpacked sfenにしても指し手文字列とその指し手の数が固定長ではないから
	バイナリサーチしにくいことには変わりないのか…。

	どのみち定跡を丸読みしてsortするコマンドは必要なんだな…。
	最終的にファイルが数百GBになる可能性がなくはないが。
	そうなったらそうなったで分割してsortてmergeするプログラム書けばいいのか…。

	やねうら大定跡、1GBを超えたら考えよう。
	しかし書き出しでそこがボトルネックになる可能性はあるな…。
	
	ファイルサイズが問題なのではないから、やはりsfen文字列でsortしてそのまま保存するのが一番良いのでは。

	makebook sort book1.db book2.db
	こうやるとbook2.dbにsortされたものが書き出される。(ように実装する。)

	→　やっとon the flyで定跡参照できるようになった。長かった…。


・Hyper-Vでのbenchテスト

	非Hyper-V 1319万nps 40threads
	Hyper-V   1132万nps 40threads // 14%ぐらいダウン
	Hyper-V   1856万nps 64threads // 40コア時の64/40倍にはなかっているが…。
	非Hyper-V 2079万nps 64threads // 無理やり64論理コア Hyper-Vを入れるとそうなった。


Hyper-V、計算資源として用いるにはオーバーヘッドが大きいように思う。

・USIプロトコルを拡張して、1プロセスで個別にコマンドを並列的に受け付けるモードを用意すべき？
	→　coutの出力がボトルネックになりかねない…。難しい。
	メモリ不足とNUMAでこんなに苦労するとは…。
	coutの出力lockを取り合って出力が詰まりそう…。
	評価関数パラメーターだけshared memory経由で共有かけられると良いのだが…。
	DLLにして分離するとか…。memory mapped file使うだとか…。

	置換表256MB*80 = 20.48GB。
	置換表だけでも馬鹿にならないな。

	DLLもmemory mapped fileも内部的にはOSのpagingの仕組みに依拠していて、
	どちらもオーバーヘッドがなくはないような…。
	ソフト上でどうにかすべきか…。
	TTは共有しててもいいから、Searchのglobalオブジェクトだけどかせば
	あとは何とかなるような気も。ああ、ThreadsとかOptionsもか。
	ただならぬ面倒くささのような気がしてきた。
	USIの並列化された独自応答部を作るほうがいいのかも知れない。
	しかしそれだと持ち時間が調整出来ないのか…。

	globalオブジェクト閉じ込めたC++のclass作って、全部そこ参照するだとか…。
	かなりの関数にそれつけて回るの大変だな。
	this_thread()とかに突っ込むか。
	pos->this_thread()->Options["..."];
	それはそれでダサい気がする。

	MemoryMappedFileを一度試してみる。
	評価関数と置換表を共有してみる。
	置換表は、別プロセスであればgeneration自体は異なるから、共有してもうまく動く(気がする)。
	よしよし、うまくいきそうな気がしてきた。


■ 2016/07/05

] V3.32

・定跡生成中の中断を実装する。
	→　この処理、難しいので定期的に保存するコードを追加することにする。
	→　追加した。

・book mergeの機能、あったほうがいいような気がしなくもない。追加してみる。
	→　実装した。うまく動いてるっぽい。

・定跡絡み。
	BookEvalDiff 定跡の第一候補手との評価値の差
	BookEvalBlackLimit 定跡の先手の評価値下限
	BookEvalWhiteLimit 定跡の後手の評価値下限
	BookDepthLimit 定跡のdepth下限(0=下限なし)

・2016MidのEVAL_LEARNバージョン、Midと統合。

	#ifdef YANEURAOU_2016_MID_ENGINE_LEARN
	#define ENGINE_NAME "YaneuraOu 2016 Mid Learn"
	#define YANEURAOU_2016_MID_ENGINE
	#define ASSERT_LV 3
	#define ENABLE_TEST_CMD
	#define EVAL_KPPT
	#define USE_SIMPLE_SEE
	#define USE_MOVE_PICKER_2016Q2
	#define USE_MATE_1PLY
	#define USE_ENTERING_KING_WIN
	#define USE_TIME_MANAGEMENT
	#define KEEP_PIECE_IN_GENERATE_MOVES
	#define ONE_PLY_EQ_1
	// 学習絡みのオプション
	#define USE_SFEN_PACKER
	#define EVAL_LEARN
	// 定跡生成絡み
	#define ENABLE_MAKEBOOK_CMD
	#endif
	→削除。

	VC++2015 (Hyper-V 8コア割当時)
	===========================
	Total time (ms) : 101001
	Nodes searched  : 68270869
	Nodes/second    : 675942

	gcc PGO(Hyper-V 8コア割当時)
	===========================
	Total time (ms) : 101246
	Nodes searched  : 68270869
	Nodes/second    : 674306

	ほぼ変わらない…。Hyper-V環境下が特殊なのかも…。
	VC++2015をupdate3にしたからなのか、gccのほう-fltoを外したからなのか…。

		※　YaneuraOu-2016-Mid_gcc.exeは、Msys2のg++でコンパイルした
		AVX2用の実行ファイルです。Visual C++2015でコンパイルしたものより10数%速いようです。
		(こちらを使ったほうがレーティングも+R30～40高いと思います)

	→　削除。


・定跡生成のときに思考対象局面の開始手数を指定できるように。startmoves 

	Hash 8192
	MultiPV 10
	Threads 12
	makebook think records1.sfen yaneura_book1.db moves 4 depth 32
	// 206node。これなら2,3日で終わるか？
	// 開始2016/07/05 6:50

	Hash 8192
	MultiPV 10
	Threads 40
	makebook think records1.sfen yaneura_book1.db startmoves 5 moves 5 depth 32
	// 323node。40スレッドなので1日で終わる？
	// 開始2016/07/06 12:30

	Hash 8192
	MultiPV 10
	Threads 40
	makebook think records1.sfen yaneura_book1.db startmoves 6 moves 6 depth 32
	// 678node。
	// 開始2016/07/06 12:30

	Hash 8192
	MultiPV 10
	Threads 12
	makebook think records1.sfen yaneura_book1.db moves 8 depth 24
	// 4418 node。
	// 開始2016/07/05 6:50 → 翌日終了。

	Hash 1024
	MultiPV 5
	Threads 4
	makebook think records1.sfen yaneura_book1.db moves 10 depth 18
	// 6000ノードほど。1秒で2,3ノード処理できるから1時間かからない模様。
	// → multipv 5で16手目までやることに。

	Hash 1024
	MultiPV 5
	Threads 8
	makebook think records1.sfen yaneura_book1.db moves 16 depth 18
	// 51000ノードほど。丸一日あればいけそう。てか32手目まで入れても知れてるような。
	// depth 18の指し手なんかあっても邪魔なだけか…。まあいいや、生成してみる。

	Hash 8192
	MultiPV 5
	Threads 12
	makebook think records1.sfen yaneura_book1.db moves 32 depth 18
	// 42万nodeの模様。2,3日で終わるか。そうか。
	// 開始2016/07/05 6:50

	→　やねうら大定跡.txtに移動。

■ 2016/07/04

] V3.31

		[HISTORY]
		PARAM_FUTILITY_AT_PARENT_NODE_SEE_DEPTH : 4 → 5(50.52%) : ←(値3,勝率49.48%,500局,有意60.76%) ,○(値4,勝率47.12%,500局,有意90.59%) ,→(値5,勝率50.52%,500局,有意39.20%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_MARGIN : 256 → 200(49.79%) : ←(値200,勝率47.93%,500局,有意83.01%) ,○(値200,勝率49.17%,500局,有意65.94%) ,→(値200,勝率49.79%,500局,有意55.44%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_DEPTH : 7 → 8(46.71%) : ←(値6,勝率46.06%,500局,有意96.22%) ,○(値7,勝率46.17%,500局,有意95.82%) ,→(値8,勝率46.71%,500局,有意93.28%) ,
		PARAM_FUTILITY_RETURN_DEPTH : 7 → 8(52.48%) : ←(値6,勝率51.14%,500局,有意29.25%) ,○(値7,勝率49.48%,500局,有意60.78%) ,→(値8,勝率52.48%,500局,有意12.79%) ,
		PARAM_FUTILITY_MARGIN_QUIET : 125 → 125(49.80%) : ←(値122,勝率46.35%,500局,有意95.01%) ,○(値125,勝率49.80%,500局,有意55.40%) ,→(値128,勝率49.38%,500局,有意62.53%) ,
		PARAM_FUTILITY_MARGIN_ALPHA : 197 → 194(51.95%) : ←(値194,勝率51.95%,500局,有意18.24%) ,○(値197,勝率49.07%,500局,有意67.54%) ,→(値200,勝率48.14%,500局,有意80.61%) ,
		PARAM_QUIET_SEARCH_COUNT : 64 → 62(56.61%) : ←(値62,勝率56.61%,500局,有意0.15%) ,○(値64,勝率49.06%,500局,有意67.61%) ,→(値66,勝率47.10%,500局,有意90.68%) ,
		PARAM_RAZORING_MARGIN4 : 554 → 554(50.61%) : ←(値546,勝率48.35%,500局,有意78.01%) ,○(値554,勝率50.61%,500局,有意37.57%) ,→(値562,勝率47.91%,500局,有意83.16%) ,
		PARAM_RAZORING_MARGIN3 : 603 → 595(51.03%) : ←(値595,勝率51.03%,500局,有意30.86%) ,○(値603,勝率48.74%,500局,有意72.43%) ,→(値611,勝率48.35%,500局,有意77.97%) ,
		PARAM_RAZORING_MARGIN2 : 570 → 578(50.82%) : ←(値562,勝率46.09%,500局,有意96.16%) ,○(値570,勝率48.76%,500局,有意72.31%) ,→(値578,勝率50.82%,500局,有意34.19%) ,
		PARAM_RAZORING_MARGIN1 : 483 → 475(48.57%) : ←(値475,勝率48.57%,500局,有意75.14%) ,○(値483,勝率48.03%,500局,有意81.86%) ,→(値491,勝率47.12%,500局,有意90.59%) ,
		PARAM_NULL_MOVE_DYNAMIC_BETA : 67 → 64(49.48%) : ←(値64,勝率49.48%,500局,有意60.73%) ,○(値67,勝率46.23%,500局,有意95.48%) ,→(値70,勝率44.58%,500局,有意99.27%) ,
		PARAM_NULL_MOVE_DYNAMIC_ALPHA : 823 → 839(48.46%) : ←(値807,勝率47.40%,500局,有意88.21%) ,○(値823,勝率45.29%,500局,有意98.34%) ,→(値839,勝率48.46%,500局,有意76.58%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_SEE_DEPTH : 4 → 3(52.69%) : ←(値3,勝率52.69%,500局,有意10.98%) ,○(値4,勝率50.62%,500局,有意37.52%) ,→(値5,勝率49.38%,500局,有意62.51%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_MARGIN : 256 → 256(52.24%) : ←(値200,勝率49.59%,500局,有意58.99%) ,○(値200,勝率52.24%,500局,有意14.94%) ,→(値200,勝率51.03%,500局,有意30.86%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_DEPTH : 7 → 8(53.10%) : ←(値6,勝率52.29%,500局,有意14.69%) ,○(値7,勝率49.69%,500局,有意57.21%) ,→(値8,勝率53.10%,500局,有意7.94%) ,
		PARAM_FUTILITY_RETURN_DEPTH : 7 → 7(52.72%) : ←(値6,勝率48.87%,500局,有意70.71%) ,○(値7,勝率52.72%,500局,有意10.84%) ,→(値8,勝率49.18%,500局,有意65.84%) ,
		PARAM_FUTILITY_MARGIN_QUIET : 128 → 125(51.16%) : ←(値125,勝率51.16%,500局,有意29.06%) ,○(値128,勝率47.28%,500局,有意89.16%) ,→(値131,勝率50.00%,500局,有意51.81%) ,
		PARAM_FUTILITY_MARGIN_ALPHA : 200 → 197(49.59%) : ←(値197,勝率49.59%,500局,有意58.99%) ,○(値200,勝率43.00%,500局,有意99.91%) ,→(値203,勝率47.42%,500局,有意88.11%) ,

	book生成テスト
	Hash 1024
	MultiPV 5
	Threads 8
	makebook think 2016.sfen yaneura_book1.db moves 16 depth 18
	→　うまく動くようになった

	適当な棋譜を食わせてざっくりと定跡を生成してみる。

	Hash 1024
	MultiPV 7
	Threads 4
	makebook think records1.sfen yaneura_book1.db moves 4 depth 24 →　完了

	Hash 1024
	MultiPV 10
	Threads 4
	makebook think records1.sfen yaneura_book1.db moves 4 depth 32 →　やりかけ

	Hash 1024
	MultiPV 5
	Threads 4
	makebook think records1.sfen yaneura_book1.db moves 8 depth 18

	とりあえず16手目までdepth18で回しておく。
	→　あかん。結構ある。これは死ぬ。8手目まで回して、あとは新しいPC来てからでいいや。
	→　定跡生成中の途中中断に対応させないとやってられない。

	Hash 1024
	MultiPV 5
	Threads 4
	makebook think records1.sfen yaneura_book1.db moves 10 depth 18


・やねうら王2016MidのLEARNバージョン、配布するか？
	→　もうしばらくしてからでいいような…。
	→　やねうら王2016MIDと統合してもいいような…。

・g++で-fltoでセグフォになる件、LONG_EFFECT_LIBRARY絡みか？
　　→　そうではなさげ。
    →　shogi.cppでSearch::init() (やねうら王2016Mid)が呼び出された瞬間に落ちている模様。g++のbugくさい。
	これ以上、どうしようもないので-fltoは付けないということにするしかない。


■　2016/07/02

] V3.29

・1手3秒500局でパラメーター自動調整

		[HISTORY]
		PARAM_NULL_MOVE_DYNAMIC_BETA : 67 → 64(49.48%) : ←(値64,勝率49.48%,500局,有意60.73%) ,○(値67,勝率46.23%,500局,有意95.48%) ,→(値70,勝率44.58%,500局,有意99.27%) ,
		PARAM_NULL_MOVE_DYNAMIC_ALPHA : 823 → 839(48.46%) : ←(値807,勝率47.40%,500局,有意88.21%) ,○(値823,勝率45.29%,500局,有意98.34%) ,→(値839,勝率48.46%,500局,有意76.58%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_SEE_DEPTH : 4 → 3(52.69%) : ←(値3,勝率52.69%,500局,有意10.98%) ,○(値4,勝率50.62%,500局,有意37.52%) ,→(値5,勝率49.38%,500局,有意62.51%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_MARGIN : 256 → 256(52.24%) : ←(値200,勝率49.59%,500局,有意58.99%) ,○(値200,勝率52.24%,500局,有意14.94%) ,→(値200,勝率51.03%,500局,有意30.86%) ,
		PARAM_FUTILITY_AT_PARENT_NODE_DEPTH : 7 → 8(53.10%) : ←(値6,勝率52.29%,500局,有意14.69%) ,○(値7,勝率49.69%,500局,有意57.21%) ,→(値8,勝率53.10%,500局,有意7.94%) ,
		PARAM_FUTILITY_RETURN_DEPTH : 7 → 7(52.72%) : ←(値6,勝率48.87%,500局,有意70.71%) ,○(値7,勝率52.72%,500局,有意10.84%) ,→(値8,勝率49.18%,500局,有意65.84%) ,
		PARAM_FUTILITY_MARGIN_QUIET : 128 → 125(51.16%) : ←(値125,勝率51.16%,500局,有意29.06%) ,○(値128,勝率47.28%,500局,有意89.16%) ,→(値131,勝率50.00%,500局,有意51.81%) ,
		PARAM_FUTILITY_MARGIN_ALPHA : 200 → 197(49.59%) : ←(値197,勝率49.59%,500局,有意58.99%) ,○(値200,勝率43.00%,500局,有意99.91%) ,→(値203,勝率47.42%,500局,有意88.11%) ,

	途中から悪化した。500局が少なすぎてSEE_DEPTHを悪いほうに変更したのが祟っている印象。

・gcc、CFLAGSにも-flto追加。

		===========================
		Total time (ms) : 105466
		Nodes searched  : 69480659
		Nodes/second    : 658796

	あまり変わらず。

・sfenのpacker、learnerと関係ないな。misc/sfen_packer.cppに移動。


■　2016/07/01

] V3.28

・学習ルーチン追加開始。

	learn/learner.cpp追加。
	gensfenコマンド追加。


・パラメーター自動調整関係

	PARAM_FUTILITY_RETURN_DEPTHが8のときにたまにASSERTに引っかかる？
	→ margin値を引いたときにevalの値が-VALUE_INFINITEを下回るのかと思ったが違うようだ。

	V3.28b
・sfenの圧縮出力追加。(かきかけ)



■　2016/06/30

] V3.27

・EVAL_LEARN絡みの作業。

  // 学習時にkppテーブルに値を書き出すためのヘルパ関数。
  void kpp_write(Square k1, BonaPiece p1, BonaPiece p2, ValueKpp value)

  // 学習時にkkpテーブルに値を書き出すためのヘルパ関数。
  void kkp_write(Square k1, Square k2, BonaPiece p1, ValueKkp value)

  を用意。

  V3.27a
・棋譜生成のためのSearchのスタブにaspiration searchを導入する。
	→　よく考えたらdepth5ぐらいでaspirationしても無駄だったのだ…。
	まあいいや。aspirationとMultiPvを導入しよう。

	> test gensfen
	うまく動いたので、とりあえずこれでいいや。

  V3.27b
・定跡ファイルの選択機能追加。


■　2016/06/29

] V3.26

	V3.26a
	・KPPTを、KKPTだけにするテストコード追加。

			秒読み200[ms]

			36.2%	
			#262
			やねうら王2016mid V326a
			KPPT=0
			#261
			やねうら王2016mid V326
			新基準。

			242-6-427(100.0% R-98.6)	


			秒読み1000[ms]

			36.2%	
			#262
			やねうら王2016mid V326a
			KPPT=0
			#261
			やねうら王2016mid V326
			新基準。

			169-13-298(100.0% R-98.5)	


			秒読み3000[ms]

			33.4%	
			#262
			やねうら王2016mid V326a
			KPPT=0
			#261
			やねうら王2016mid V326
			新基準。

			205-15-409(100.0% R-120.0)	

	KPPに手番がないとR100ぐらい下がるのか。
	評価関数の計算で2割ぐらい得するから、R50ぐらいは取り戻せるとして。
	R60ダウンなのか..。思ったより大きいような…。そうでもないような…。
	もう少し評価関数の質が良ければKPPには手番が要らない可能性も。


	・マルチスレッド時のehashの効果調べる。

	eval hash有効 4スレッド比較

		秒読み300[ms]

		50.3%	
		#264
		やねうら王2016mid V326
		no ehash Thread4
		#263
		やねうら王2016mid V326
		新基準。Thread4

		637-30-630(42.2% R1.9)	

	差は微妙。なくてもいいなら無しにしたいぐらいだが…。
	メモリまわりが速いなら意味があるのかも…。
	とりあえず、長い持ち時間でもテスト。

		秒読み2000[ms]

		48.5%	
		#264
		やねうら王2016mid V326
		no ehash Thread4
		#263
		やねうら王2016mid V326
		新基準。Thread4

		64-5-68(66.8% R-10.5)	

	計測に時間かかりすぎてまともに実験できない。現実的ではない。
	短い時間での実験結果を信じることにする。

		秒読み1000[ms]

		50.9%	
		#264
		やねうら王2016mid V326
		no ehash Thread4
		#263
		やねうら王2016mid V326
		新基準。Thread4

		353-32-341(31.1% R6.0)	

	1秒でやってみたが、やはり、ehashはほとんど効果なさげ。
	という結論を得た。
			

■　2016/06/28

] V3.25

	・EVAL_KPPT_FAST

	V3.25a
	KPPT_FASTのdo_a_black/white()をVPGATHERDD化。ベンチ上、速くなったのかどうかすらわからない。
	gccでビルドしたほうはセグフォで落ちる。なんぞこれ。

	do_a_black/white()、玉が移動したときしか関係ないし、しかもおまけの処理だから、
	ここを高速化しても無駄であったか…。そうか…。

	VPGATHERDD自体がHaswellでは遅いのと、垂直addが効率良くないのと二重苦だな…。

		// これに相当する命令がない。簡単に書けない。
		u32 a32[8];
		_mm256_storeu_si256((__m256i*)&a32,data_sum);
		sum[0] = a32[0] + a32[4];
		sum[1] = a32[1] + a32[5];

	gcc、こう書いても落ちる。


		秒読み200[ms]

		50.0%	
		#260
		やねうら王2016late V325a
		evaluate() VPGATHERDD化
		#259
		やねうら王2016late V325
		新基準

		2331-68-2327(47.7% R0.3)	

	強くなってない。速くなってない。なにこれ。


	V3.25b
	玉が移動したときのΣKPPの片側を求めるのは、VPGATHERDDですこぶる効率的に書く方法を発見した。
	というか、思い出した。




■　2016/06/27

] V3.24

	・魔女の実行時間、プロファイラで調べる。
　	  →　調べるまでもなくevaluate()だわ。

	・KPPTの評価関数の差分計算、もう少し簡略化出来るかも。
 　	  →　いい方法思いついたので自分でやる。
	・評価関数のAVX2化。→　tanuki-さんにお願い中 →　評価関数に手番を入れてから →　AVX2化考える
 　	  →　いい方法思いついたので自分でやる。

	・to_sq()→sqww_to_sq()に変更。to_sq()をmove_to()のaliasに。

	V3.24a

	・KPPTのevaluate()高速化のためにソースコード整理していく。
	・Apery、魔女風にした。


		秒読み100[ms]

		52.9%	
		#257
		やねうら王2016mid V324a
		evaluate() リファクタリング
		#256
		やねうら王2016mid V324
		新基準。

		736-11-654(1.4% R20.5)	

	nps上がった分、少し強くなった可能性。

		gcc
		===========================
		Total time (ms) : 104813
		Nodes searched  : 69480659
		Nodes/second    : 662901


		秒読み15000[ms]

		51.1%	
		#258
		やねうら王2016mid V324a-gcc
		evaluate() リファクタリング
		#0
		silent_majority_V1.1公式
		1スレッド

		70-9-67(36.6% R7.6)	

	15秒で魔女に勝ち越したのは初めて。
	もう少し対局数をやったほうがいいが、長い時間だとマシンが長時間専有されて何とも…。
	まあ、互角ということでいいや。


■　2016/06/26

] V3.23

	V3.23a
	-    // IID、null move、singular extensionの判定のときは浅い探索なのでこのときに
	-    // killer等を更新するのは有害である。
	-    if (ss->skipEarlyPruning)
	-      return;
	
	これ、もはやないほうがいいのか…。


		// fail lowを引き起こした前nodeでのcounter moveに対してボーナスを加点する。
		else if (depth >= 3 * ONE_PLY
		  && !bestMove                        // bestMoveが無い == fail low
		  && !InCheck
		  && !pos.captured_piece_type()
		  && is_ok((ss - 1)->currentMove)
	-      && is_ok((ss - 2)->currentMove))
		{

	fail low bonusも修正したほうがいいな。

		秒読み300[ms]

		50.1%	
		#249
		やねうら王2016mid V323a
		update_stats()変更。
		#248
		やねうら王2016mid V323
		新基準

		578-21-576(47.7% R0.6)	

	短い時間において弱くはなっていないので採用。

	move_to → to_sq()にしたほうがStockfishと互換性が上がるのでは…。
	変な独自性出さないほうがいいような…。
	→　これはまだいいか..

	V3.23b
	ehash、bench値は上がらないが、2手前の局面で考えた結果が生きるので
	やったほうがいいのでは。有効にして比較する。

		秒読み300[ms]

		49.6%	
		#250
		やねうら王2016mid V323b
		ehash有効。
		#248
		やねうら王2016mid V323
		新基準

		408-16-414(59.6% R-2.5)	


		秒読み2000[ms]

		50.7%	
		#250
		やねうら王2016mid V323b
		ehash有効。
		#248
		やねうら王2016mid V323
		新基準

		106-5-103(39.1% R5.0)	


		→　よくわからない。スレッド数が多いなら他のスレッドの計算結果が使えていいのかも。
		互角ぐらいなら入れたい気はする。入れる。


	V3.23c
		-	PARAM_DEFINE PARAM_FUTILITY_AT_PARENT_NODE_MARGIN = 170;
		+	PARAM_DEFINE PARAM_FUTILITY_AT_PARENT_NODE_MARGIN = 256;
		いったん元に戻したほうが良いのでは..

			value = search<NonPV>(pos, ss, rBeta - 1, rBeta, depth * PARAM_SINGULAR_SEARCH_DEPTH / 256, cutNode);
			ss->skipEarlyPruning = false;
			ss->excludedMove = MOVE_NONE;

		-	ss->moveCount = moveCount; // 破壊したと思うので修復しておく。


		  if (givesCheck
		-	&& moveCount == 1
		+	&& !moveCountPruning
			&& pos.see_sign(move) >= VALUE_ZERO)
			extension = ONE_PLY;


			else if (depth >= 3 * ONE_PLY
			  && !bestMove                        // bestMoveが無い == fail low
		-	  && !InCheck
			  && !pos.captured_piece_type()
			  && is_ok((ss - 1)->currentMove))
			{
			  // 指し手のなかに移動後の駒が格納されているのでこれで取得できる。
			  Piece prevPc = pos.moved_piece_after((ss - 1)->currentMove);

		  if (  givesCheck
			-   && moveCount == 1
	   		+	&& !moveCountPruning
			&&  pos.see_sign(move) >= VALUE_ZERO)
			extension = ONE_PLY;

			これやはり、やりすぎであったか…。

				秒読み1000[ms]

				53.3%	
				#251
				やねうら王2016mid V323c
				see parant nodeでのmargin変更など。
				#248
				やねうら王2016mid V323
				新基準

				313-11-274(4.9% R23.1)	

			少し上がったか。

	V3.23d
			  // 捕獲する指し手か、歩の成りの指し手であるかを返す。
			  bool capture_or_pawn_promotion(Move m) const
			  {
	+		#ifdef KEEP_PIECE_IN_GENERATE_MOVES
	+			// 移動させる駒が歩かどうかは、Moveの上位16bitを見れば良い
	+			return (is_promote(m) && raw_type_of(moved_piece_after(m)) == PAWN) || capture(m);
	+		#else
				return (is_promote(m) && type_of(piece_on(move_from(m)))==PAWN) || capture(m);
	+		#endif
			  }

			少し高速化。


			null moveのとき、stateEval + 2*Tempo、良くないのでは..

	-		  if ((ss - 1)->currentMove == MOVE_NULL)
	-		    eval = ss->staticEval = -(ss - 1)->staticEval + 2 * Tempo;

	-		ss->staticEval = bestValue =
	-		  (ss - 1)->currentMove != MOVE_NULL ? evaluate(pos)
			                                     : -(ss - 1)->staticEval + 2 * Tempo;
	+		ss->staticEval = bestValue = evaluate(pos);

			秒読み300[ms]

			45.1%	
			#252
			やねうら王2016mid V323d
			null moveのときのevaluate()変更。
			#251
			やねうら王2016mid V323c
			see parant nodeでのmargin変更など。

			246-8-299(99.0% R-33.9)	

			なぜか弱くなった。npsも少し落ちたような感じ。
			null move、なんでこんななるのん..。

	+	  // この処理、入れたほうがいいようだ。一見するとevaluate()は上で手番つきで求めているから
	+	  // これをやると不正確になるだけのようであるが、null moveした局面で手番つきの評価関数を呼ぶと
	+	  // 駒に当たっているものがプラス評価されて、評価値として大きく出すぎて悪作用があるようだ。

		という結論になった。


		魔女公式と比較。


			秒読み3000[ms]

			50.5%	
			#254
			やねうら王2016mid V323e gcc
			戻した。
			#0
			silent_majority_V1.1公式
			1スレッド

			204-10-200(40.2% R3.4)	


	V3.23f
	test gensfenコマンドのデバッグ中に気づいたが、
	金相当のMoveの上位16bitに駒を金としていたのでこれがkillerとかcountermoveになったときは
	非合法手と扱いになるバグがあるようだ。

		  auto from = pieces.pop();
		  // fromの升にある駒をfromの升においたときの利き
		- const auto Pt0 = pos.piece_on(from);
		- const auto Pt = type_of(Pt0);
		- auto target2 = effects_from(Pt0, from, occ) & target;
		- MAKE_MOVE_TARGET(target2);
		+  const auto Pt = pos.piece_on(from);
		+  auto target2 = effects_from(Pt, from, occ) & target;
		+  MAKE_MOVE_TARGET_UNKNOWN(target2);
	
	あとQUIET_CHECKSか。そうか。

		-  case PRO_PAWN  :
		-  case PRO_LANCE :
		-  case PRO_KNIGHT:
		-  case PRO_SILVER:
		+  case PRO_PAWN  : GEN_MOVE_GOLD_CHECK     (PRO_PAWN  , goldEffect  ); break;
		+  case PRO_LANCE : GEN_MOVE_GOLD_CHECK     (PRO_LANCE , goldEffect  ); break;
		+  case PRO_KNIGHT: GEN_MOVE_GOLD_CHECK     (PRO_KNIGHT, goldEffect  ); break;
		+  case PRO_SILVER: GEN_MOVE_GOLD_CHECK     (PRO_SILVER, goldEffect  ); break;
		  case GOLD      : GEN_MOVE_GOLD_CHECK     (GOLD      , goldEffect  ); break;


		pseudo_legal()で落ちたときのデバッグ用のコード

            for (auto m2 : pv)
              cout << m2 << " ";
            cout << endl;

            if (!pos.pseudo_legal(m) || !pos.legal(m))
            {
              auto mg = MoveList<NON_EVASIONS>(pos);
              for (auto move : mg)
              {
                cout << move << " : " << Piece(move >> 16) << " : " ;
                if (!pos.pseudo_legal(move))
                  cout << "not pseudo_legal →　" << move;
                cout << endl;
              }

              cout << endl;
            }

			  if (!pos.pseudo_legal(move))
			  {
				cout << pos << move;
			  }

				秒読み300[ms]

				61.3%	
				#255
				やねうら王2016mid V323f gcc
				genmove修正。
				#254
				やねうら王2016mid V323e gcc
				戻した。

				111-1-70(0.1% R80.1)	

			ひどいバグであった模様。
			短い時間だと相対的にqsearch()の割合が高いために影響がもろに出るようだ。


			秒読み3000[ms]

			47.3%	
			#255
			やねうら王2016mid V323f gcc
			genmove修正。
			#0
			silent_majority_V1.1公式
			1スレッド

			214-13-238(88.0% R-18.5)	

		回数が少ないので何とも。たぶん互角ぐらい。
		10秒で魔女と丸1日回しておく。


			秒読み15000[ms]

			45.3%	
			#255
			やねうら王2016mid V323f gcc
			genmove修正。
			#0
			silent_majority_V1.1公式
			1スレッド

			505-63-611(99.9% R-33.1)	

	まだR33も離れているのか。evaluate()、AVX2化するわ。それでチャラだ。

] V3.22

・futilityとrazoringのパラメーター、元に戻してみる。

		秒読み3000[ms]

		49.7%	
		#246
		やねうら王2016mid V322a
		futilityとrazoringパラメーター戻した
		#0
		silent_majority_V1.1公式
		1スレッド

		357-24-361(57.4% R-1.9)	

	ほぼ互角。

	V3.22b
	LONG_EFFECT_LIBRARY利用でどれくらいの勝率になるのか。
	→　nps5%程度ダウン＋1手詰め発見率5%程度ダウンのコンボなので
	強くなるはずがないが…。1手詰めを3手詰めに変更するなら意味があるかも。
	
	long_effect.cpp、g++でbuild通らない。修正。

		long effect有効、gcc
		===========================
		Total time (ms) : 63803
		Nodes searched  : 42028435
		Nodes/second    : 658721

	そこまで遅くはない印象。

		秒読み3000[ms]

		45.6%	
		#247
		やねうら王2016mid V322b
		利き利用
		#0
		silent_majority_V1.1公式
		1スレッド

		169-12-202(96.1% R-31.0)	

	mate1()の発見率が5%落ちることと、nps 5%ダウン。結構勝率に影響するんだな…。
	同種ソフト対決なのも影響してるのかも知れないが。


		秒読み15000[ms]

		45.3%	
		#246
		やねうら王2016mid V322a
		futilityとrazoringパラメーター戻した
		#0
		silent_majority_V1.1公式
		1スレッド

		377-49-456(99.7% R-33.0)	

	まだ何らか負けているようだ。


	moved_piece_after()やめて、移動させる駒になっていてもどうせ歩のpromoteは除外されるので
	あまり変わらないのかも。桂を成る場合と成らない場合とが同一視されるのがちょっと嫌だな。
	やはり、魔女のこの部分の実装は良いとは思えないのだが…。


] V3.21

	V3.21a
・history、整理

		秒読み300[ms]

		51.8%	
		#242
		やねうら王2016mid V321a
		history整理
		#241
		やねうら王2016mid V321
		新基準

		298-6-277(17.9% R12.7)	


		秒読み10000[ms]

		50.0%	
		#243
		やねうら王2016mid V321b
		history整理
		#0
		silent_majority_V1.1公式
		1スレッド

		79-9-79(53.2% R0.0)	

		魔女と互角ぐらい？


移動させる駒にしたものと比較

	V3.21b

			#define USE_DROPBIT_IN_STATS
			#define KEEP_PIECE_IN_GENERATE_MOVES

		これ、USE_DROPBIT_IN_STATSをundefするとすごく弱くなる。(-R170ぐらい)
		何か修正忘れているのだと思う。この弱くなる原因をよく調べたほうがいい。

			  // Moveの上位16bitのvaridation
		#if 1
			  if (is_drop(move))
			  {
				if (move_dropped_piece(move) + Piece(pos.side_to_move()==BLACK ? 0 : PIECE_WHITE) + PIECE_DROP  != Piece(move >> 16))
				{
				  cout << pos << move << ":" << move_dropped_piece(move);

				}
			  } else if (!is_promote(move)) {
				if (pos.moved_piece_after_ex(move) != pos.piece_on(move_from(move)))
				{
				  cout << pos << move;
				}
			  } else {
				if (pos.moved_piece_after_ex(move) != pos.piece_on(move_from(move)) + PIECE_PROMOTE)
				{
				  cout << pos << move;
				}
			  }
		#endif


		→　わかった。move16_to_move()で復元するときに+32してしまっていた。これで範囲外の配列壊していたのか。

		  // moved_piece_before()の移動後の駒が返る版。
		  // KEEP_PIECE_IN_GENERATE_MOVESのときは単にmoveの上位16bitを返す。
		  Piece moved_piece_after(Move m) const {
		#ifdef    KEEP_PIECE_IN_GENERATE_MOVES
			// 上位16bitにそのまま格納されているはず。
		//    return Piece((m >> 16) & ~32); // DROP BITを飛ばす
			return Piece(m >> 16);
		#else
			return is_drop(m)
			  ? (move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE))
			  : is_promote(m) ? Piece(piece_on(move_from(m)) + PIECE_PROMOTE) : piece_on(move_from(m));
		#endif
		  }

		  moved_piece_after_ex()これ、要らないな。消そう。

		  pseudo_legal_s()でdropのとき+32してた。これか。

			rtime 100[ms]

			49.1%	
			#243
			やねうら王2016mid V321b
			history整理
			#242
			やねうら王2016mid V321a
			DROPBITなし

			279-6-289(67.8% R-6.1)	

	互角ぐらいになった。短い時間だとhistoryが小さくなるとCPU cacheの効率が良くなるからか？
	1000回ぐらいまわしてから判断しよう。

			rtime 1000[ms]

			50.2%	
			#242
			やねうら王2016mid V321a
			DROPBITなし
			#243
			やねうら王2016mid V321b
			history整理

			1084-47-1074(41.5% R1.6)	

	DROPBIT、やはりなくてもいいぐらいだな…。なしにする。

		秒読み10000[ms]

		47.6%	
		#244
		やねうら王2016mid V321a
		Dropなし、gcc
		#0
		silent_majority_V1.1公式
		1スレッド

		175-21-193(83.9% R-17.0)	

	まだわずかに負けているようだ。この原因をよく調べる。


■　2016/06/25

] V3.20

・PVの出力の抑制機能追加。(出力が詰まるため)

・新SEE周り、見直す。

		秒読み3000[ms]

		37.0%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		91-4-155(100.0% R-92.5)	

	新seeひどすぎ。

	旧see()、少し簡略化できた。

	新see()
	-		Bitboard occupied = pieces();
	+		Bitboard occupied;
	この初期化必要だった。


		秒読み500[ms]

		49.8%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		141-8-142(54.7% R-1.2)	


		秒読み3000[ms]

		57.5%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		61-2-45(4.9% R52.8)	

	→　新しいほうのsee()のほうがかなり優秀っぽい。前のsee()とは何だったのだ…。
	前のsee()バグっている可能性が微レ存。

	もう少し長い時間で実験してみる。

		秒読み5000[ms]

		51.3%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		471-23-448(21.4% R8.7)	

		強くはなっていそう。


	V3.20b

	    attackers = (stmAttackers | attackers_to(~stm, to, occupied)) & occupied;

	この & occupied、不要のはずなのだがこれを無くすとbenchの探索node数が変わる。おかしい。
	よく調べる。

		===========================
		Total time (ms) : 58766
		Nodes searched  : 34588434
		Nodes/second    : 588579

		gcc
		===========================
		Total time (ms) : 53064
		Nodes searched  : 34588434
		Nodes/second    : 651824

	→　理由わかった。KINGをcaptureしたときに、stmAttackersが有ることになってしまうから
	attackers & occupiedみたいな処理が必要になるのか。minAttackersでKINGを返すときに & occupied して返すべきなのか。
	(Aperyはそうなっている)	Stockfishのコードと等価にするにはいまのコードが正しいな。そうか…。

	Aperyのコードがわずかに無駄があるということなんだな。平岡さんに報告しよう。
	https://github.com/HiraokaTakuya/apery/issues/6

	see_sign()、いい加減にするのやめておいたほうがいいのでは…。

	#if 0
	  if (capture(move))
	  {
		// 捕獲する指し手で、移動元の駒の価値のほうが移動先の駒の価値より低い場合、これでプラスになるはず。
		// (取り返されたあとの成りを考慮しなければ)
		const Piece ptFrom = type_of(piece_on(move_from(move)));
		const Piece ptTo = type_of(piece_on(move_to(move)));
		if (CapturePieceValue[ptFrom] <= CapturePieceValue[ptTo])
		  return static_cast<Value>(1);
	  }
	#endif

		秒読み1000[ms]

		47.2%	
		#237
		やねうら王2016mid V320b
		新see()改良
		#236
		やねうら王2016mid V320a
		新see()

		258-6-289(91.4% R-19.7)	

	よくなってない。もう少し長い時間で回してみる。

		秒読み4000[ms]

		49.2%	
		#237
		やねうら王2016mid V320b
		新see()改良
		#236
		やねうら王2016mid V320a
		新see()

		127-11-131(62.2% R-5.4)	

	変わらず。Stockfishでもこの判定になっているから、ここ変えても変わらないのかも知れない。

	see_sign()の判定、kingでcaptureするときは常にプラスを返して良いのでは…。うーん..

    // KINGで取る手は合法手であるなら取り返されないということだから、ここではプラスを返して良い。
    // ゆえに、中盤用のCapturePieceValue[KING]はゼロを返して良いのでは。

	-   if (CapturePieceValue[ptFrom] <= CapturePieceValue[ptTo])
	+   if (CapturePieceValue[ptFrom] <= CapturePieceValue[ptTo] || ptFrom == KING)

	こうするか。

			秒読み300[ms]

			51.6%	
			#238
			やねうら王2016mid V320c
			新see()改良
			#236
			やねうら王2016mid V320a
			新see()

			489-11-458(14.9% R11.4)	

	勝率が上がったが、この実装おかしいなぁ…。

	CapturePieceValue、やはりKINGはゼロにするのが正しいのでは。

		// KINGの場合、プラスが返るが、その場合、moveは非合法手であるから、そのあと引っかかるはずなので
		// この判定、入れなくてもいいかも。
		//if (captured == KING)
		//  return Value(-CapturePieceValue[KING]);


		秒読み300[ms]

		51.3%	
		#239
		やねうら王2016mid V320d
		CapturePieceValue[KING]=0
		#238
		やねうら王2016mid V320c
		新see()改良

		401-11-381(22.6% R8.9)	

	弱くはなってなさそうなのでおk。

	gccでコンパイルして1手5秒で魔女と対戦させておく。

		秒読み5000[ms]

		50.0%	
		#240
		やねうら王2016mid V320d gcc
		CapturePieceValue[KING]=0
		#0
		silent_majority_V1.1公式
		1スレッド

		112-12-112(52.7% R0.0)	

	ほぼ互角っぽい。

		gcc PGO
		===========================
		Total time (ms) : 48621
		Nodes searched  : 32357232
		Nodes/second    : 665499

	1,2%速くなった程度？

	魔女と10秒でテスト。

		秒読み10000[ms]

		45.5%	
		#240
		やねうら王2016mid V320d gcc
		CapturePieceValue[KING]=0
		#0
		silent_majority_V1.1公式
		1スレッド

		438-52-525(99.8% R-31.5)	

	まだ少し負けているのか。

・ASSERT外して何故速くならないのか調べる。
	→　assert()、探索の時間のかかるところにはあまり入ってないからかな。
・プロファイラで調べる。
	
	Eval::calc_diff_kpp             40.29%
	Position::attackers_to          10.82%
	TranspositionTable::probe       10.81%
	is_mate_in_1ply                  3.79%
	MovePicker::generate_next_stage  2.69%

	なにこれ。
	評価関数40%でかすぎ。
	probe時間かかりすぎ。
	attackers_toも重すぎ。

	attackers_to、template<Color us>とかに分けるとか..。

	NullMoveのときにprefetchしたほうがいいのでは。
	misc.cppにprefetch追加。
	TTのfirst_entry()追加。
	→　どちらが速いかほぼ計測不能。

	利きを使わないmate1ply()はテーブル使ってもう少し速く出来るはず＆mate3にすれば
	もうちょっと強くなるはず。


■　2016/06/24

] V3.19

	gccでコンパイル
	===========================
	Total time (ms) : 48419
	Nodes searched  : 34145554
	Nodes/second    : 705209

	めっちゃ速くなった。AVX用のinclude header整理したのが良かったのか…？
	evaluate()でcompute_evalのときにSSE使えてなかったとか？	うーん。それが原因ではなさげなのだが。

	VC++2015
	===========================
	Total time (ms) : 52424
	Nodes searched  : 34145554
	Nodes/second    : 651334



■　2016/06/23

] V3.18

・mate間違う局面を見つけた。

	position startpos moves 7g7f 3c3d 6g6f 8c8d 7i6h 7a6b 5g5f 5c5d 3i4h 3a4b 4i5h 4a3b 5h6g 5a4a 6i7h 7c7d 6h7g 6b5c 2g2f 5d5e 5f5e 2b5e 2f2e 5c5d 5i6i 4b3c 4h5g 8b5b 6f6e 5d6e 5g6f 6e6f 7g6f 5e8b P*5e 4a3a S*8c 8b7a 8c7d+ 6a7b 6i7i 3a2b 8h7g 7b7c 7d7c 8a7c 7g6h 7c8e 8g8f P*7g 8i7g 8e7g+ 6h7g 7a3e G*4f 3e7a N*4e 3c4d 5e5d 5b5d 6f5e 5d7d 5e4d 4c4d S*6e 7d7b P*6b 7a6b 6e5d P*7e P*5c S*4c 5d4c 3b4c S*6a 7b7a 6a5b 4c5d 5b6c 7e7f 6g7f 7a7f 6c5d+ N*6f 2e2d 2c2d 7g6f 7f6f 5d4d B*5g P*6h P*6g 2h2d P*2c G*3c 2b3a N*4c 3a4a 3c3b 4a3b 2d3d

	静止探索絡みだな、これ。
	evasionですべての指し手を生成していない可能性とかも…。

	setoption name Threads value 1
	position startpos moves 7g7f 3c3d 6g6f 8c8d 7i6h 7a6b 5g5f 5c5d 3i4h 3a4b 4i5h 4a3b 5h6g 5a4a 6i7h 7c7d 6h7g 6b5c 2g2f 5d5e 5f5e 2b5e 2f2e 5c5d 5i6i 4b3c 4h5g 8b5b 6f6e 5d6e 5g6f 6e6f 7g6f 5e8b P*5e 4a3a S*8c 8b7a 8c7d+ 6a7b 6i7i 3a2b 8h7g 7b7c 7d7c 8a7c 7g6h 7c8e 8g8f P*7g 8i7g 8e7g+ 6h7g 7a3e G*4f 3e7a N*4e 3c4d 5e5d 5b5d 6f5e 5d7d 5e4d 4c4d S*6e 7d7b P*6b 7a6b 6e5d P*7e P*5c S*4c 5d4c 3b4c S*6a 7b7a 6a5b 4c5d 5b6c 7e7f 6g7f 7a7f 6c5d+ N*6f 2e2d 2c2d 7g6f 7f6f 5d4d B*5g P*6h P*6g 2h2d P*2c G*3c 2b3a N*4c 3a4a 3c3b 4a3b 2d3d
	go infinite

	利きを使わない1手詰め判定、バグがあった。とほほ。

	敵の合駒が歩以外にないという条件を間違えて自駒が歩以外ないという条件になっていた。とほほ。
	-  if (hand_count(ourHand , PAWN) == (int)ourHand)

		秒読み300[ms]

		48.4%	
		#231
		やねうら王2016mid V318
		mate1ply()バグ修正。
		#228
		やねうら王2016mid V317
		基準。

		266-7-284(79.1% R-11.4)	

	バグ取ったのに弱くなった気がする。
	razor margin変えたのとcheck_info_update()のタイミングが早くなったからか…。つらい..。

		秒読み300[ms]

		51.2%	
		#231
		やねうら王2016mid V318
		mate1ply()バグ修正。
		#228
		やねうら王2016mid V317
		基準。

		262-4-250(28.3% R8.1)	

	まあいいや、ほぼ互角ということで。

	V3.18a
	mate1ply()、ランダムプレイヤーでテストする。

	歩の移動による不成の王手による詰み、間違えてた。
		-    to = sq_king + (us == BLACK ? SQ_U : SQ_D);
		+    to = sq_king + (us == BLACK ? SQ_D : SQ_U);

	歩の移動による成りの王手による詰み、間違えてた。

		mate found = 10000 , mate miss = 89 , mate found rate  = 99.1179%
		mate found = 20000 , mate miss = 154 , mate found rate  = 99.2359%
		mate found = 30000 , mate miss = 235 , mate found rate  = 99.2228%
		mate found = 40000 , mate miss = 322 , mate found rate  = 99.2014%
		mate found = 50000 , mate miss = 438 , mate found rate  = 99.1316%
		mate found = 60000 , mate miss = 536 , mate found rate  = 99.1146%
		mate found = 70000 , mate miss = 632 , mate found rate  = 99.1052%
		mate found = 80000 , mate miss = 746 , mate found rate  = 99.0761%
		mate found = 90000 , mate miss = 854 , mate found rate  = 99.06%
		mate found = 100000 , mate miss = 940 , mate found rate  = 99.0688%

	いっぱい引っかかってワロタ。
	mate foundは99%付近か。利きによる詰みmate1ply()は93%ちょいだったのでかなりいいみたい…。

	こんな重大なバグ修正したのに0.3秒では差がほとんどつかない…。不思議なものだ。

		秒読み300[ms]

		50.5%	
		#232
		やねうら王2016mid V318a
		mate1ply()バグ修正。
		#230
		やねうら王2016mid V317b
		razoring改善。

		196-2-192(40.0% R3.6)	


		秒読み3000[ms]

		53.8%	
		#232
		やねうら王2016mid V318a
		mate1ply()バグ修正。
		#230
		やねうら王2016mid V317b
		razoring改善。

		98-5-84(13.3% R26.8)	
	
	長い時間になるにつれて、探索node数が増えるのでmate1ply()で間違う局面が増えるから、
	それによる負けが増える…はず。つまり長い時間においてはこれが差がつく一因であった…はず。


■　2016/06/22

] V3.17

・razoring margin 0.1秒で12時間ほどチューンして、そのあと秒数を広げながらチューンしなおして、
　最終的に強くなったかどうかを長い持ち時間で検証する。

	V3.17a

	・王手延長の単純化	
		-          || ( !moveCountPruning && pos.see_sign(move) >= VALUE_ZERO)))
		+          ||  pos.see_sign(move) >= VALUE_ZERO)))

	・IIDのとき、常にcut nodeにするのではなく、そのnodeのcutNodeを伝播させる
		-  search<NT>(pos, ss, alpha, beta, d, true);
		+  search<NT>(pos, ss, alpha, beta, d, cutNode);

			秒読み1000[ms]

			50.3%	
			#229
			やねうら王2016mid V317a
			simplify check extension
			#228
			やねうら王2016mid V317
			基準。

			332-13-328(42.3% R2.1)	

		ほぼ変わらない。簡単に計測できる量ではない。

	V3.17b
	PARAM_RAZORING_MARGIN4 : 570 → 586(53.33%) : ←←(値554,勝率49.96%,1872局,有意51.14%) ,←(値562,勝率49.35%,1872局,有意67.61%) ,→(値578,勝率50.77%,1872局,有意29.44%) ,→→(値586,勝率53.33%,1872局,有意0.97%) ,
	PARAM_RAZORING_MARGIN3 : 619 → 619(50.00%) : ←←(値603,勝率49.84%,1872局,有意54.54%) ,←(値611,勝率49.15%,1872局,有意72.51%) ,→(値627,勝率49.63%,1872局,有意60.14%) ,→→(値635,勝率49.23%,1872局,有意70.56%) ,
	PARAM_RAZORING_MARGIN2 : 578 → 578(50.00%) : ←←(値562,勝率49.39%,1872局,有意66.52%) ,←(値570,勝率50.65%,1872局,有意32.43%) ,→(値586,勝率49.76%,1872局,有意56.78%) ,→→(値594,勝率50.20%,1872局,有意44.35%) ,
	PARAM_RAZORING_MARGIN1 : 483 → 483(50.00%) : ←←(値467,勝率48.48%,3744局,有意90.41%) ,←(値475,勝率47.33%,1872局,有意96.98%) ,→(値491,勝率49.39%,1872局,有意66.54%) ,→→(値499,勝率50.61%,1872局,有意33.45%) ,

			秒読み1000[ms]

			51.4%	
			#230
			やねうら王2016mid V317b
			razoring改善。
			#228
			やねうら王2016mid V317
			基準。

			323-10-306(23.6% R9.4)	
	
	弱くはなっていなさそうなので良しとする。


] V3.16

	PARAM_RAZORING_MARGIN4 : 554 → 570(53.16%) : ←←(値538,勝率50.97%,1872局,有意24.74%) ,←(値546,勝率50.20%,1872局,有意44.35%) ,→(値562,勝率51.41%,3744局,有意11.27%) ,→→(値570,勝率53.16%,1872局,有意1.36%) ,
	PARAM_RAZORING_MARGIN3 : 603 → 619(52.31%) : ←←(値587,勝率49.16%,3744局,有意76.42%) ,←(値595,勝率49.56%,1872局,有意62.28%) ,→(値611,勝率50.08%,1872局,有意47.72%) ,→→(値619,勝率52.31%,3744局,有意2.39%) ,
	PARAM_RAZORING_MARGIN2 : 570 → 578(51.59%) : ←←(値554,勝率49.84%,1872局,有意54.53%) ,←(値562,勝率49.19%,3744局,有意75.71%) ,→(値578,勝率51.59%,3744局,有意8.56%) ,→→(値586,勝率44.50%,624局,有意99.73%) ,
	PARAM_RAZORING_MARGIN1 : 483 → 483(50.00%) : ←←(値467,勝率49.84%,1872局,有意54.54%) ,←(値475,勝率50.24%,1872局,有意43.21%) ,→(値491,勝率50.73%,1872局,有意30.43%) ,→→(値499,勝率50.65%,1872局,有意32.44%) ,

	assert外しても速くならないな…。
	VS2015、assertのマクロ、除去出来ていない可能性が..

		秒読み3000[ms]

		54.3%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		107-5-90(10.0% R30.1)	

	静止探索のcheck_info_update()、元の位置に戻してなかった。

		秒読み10000[ms]

		44.8%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		125-11-154(96.4% R-36.2)	

	差は縮まってきた。npsさえ出れば魔女には勝っているのでは。
	20秒でもテストしておく。

		秒読み20000[ms]

		50.5%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		49-4-48(42.0% R3.6)	

	ほぼ互角のようだ。よしよし。

	gcc用、コンパイルしなおした。

		秒読み3000[ms]

		52.4%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		55-1-50(27.9% R16.6)	

	利きを求める部分以外はSSEなしでもなんとかなるかも知れないので、
	SSE2オプションを用意して準備をしていく。
	よく考えたらSSE4と4.1って別なのか。そうか…。
	SSE4用のオプションも用意する。
	これでSSE2用のバイナリがSSE2で動くかも。
	あとSSEなしでも動くかも。

	AperyのBitboardのoperator==()の実装、良くないのでGitHubで報告しておいた。

	EvalSumのnoSSE実装用意してなかった。用意する。
	というかUSE_AVX2でAVX2のコンストラクタ実装使っていなかった。
	
	EvalSum、eval/に移動。kppt_evalsumとリネーム

		VC++2015
		===========================
		Total time (ms) : 115619
		Nodes searched  : 72105321
		Nodes/second    : 623645

		gcc
		===========================
		Total time (ms) : 110433
		Nodes searched  : 72105321
		Nodes/second    : 652932

	やねうら王2016Mid、SSE42、SSE4、SSE2、noSSE用のバイナリも用意。

	ToDoより
	・ASSERT外してgccでビルドして2016 Midをリリース。
	→　した。
	・SSE2用バイナリを用意する。
	→　実験環境＆デバッグ環境がなくてよくわからない。
	→　とりあえずした。


■　2016/06/21

] V3.15

gcc 対応。__popcnt →　mm_popcnt_u64を使うと良いらしい。
	#include <nmmintrin.h>
	#define POPCNT32(a) _mm_popcnt_u64(a)
	#define POPCNT64(a) _mm_popcnt_u64(a)

		gcc
		===========================
		Total time (ms) : 128211
		Nodes searched  : 80011406
		Nodes/second    : 624060

		VC2015
		===========================
		Total time (ms) : 128684
		Nodes searched  : 80011406
		Nodes/second    : 621766

		何も変わってなかった。あれれ…。そして速くなっているな。
		FORCE_INLINEをつけた影響で少し速くなったのか？はてはて。

		BitboardのpopまわりにFORCE_INLINE追加した。
		movegen.cppにもFORCE_INLINE追加した。→　コンパイルがめっちゃ遅くなった。
		→　少し減らした。

		VC2015
		===========================
		Total time (ms) : 131980
		Nodes searched  : 80011406
		Nodes/second    : 606238

		gcc
		===========================
		Total time (ms) : 126935
		Nodes searched  : 80011406
		Nodes/second    : 630333

		gcc 仮想環境の外。4771
		===========================
		Total time (ms) : 122866
		Nodes searched  : 80011406
		Nodes/second    : 651208

		VC2015 仮想環境の外。4771
		===========================
		Total time (ms) : 125457
		Nodes searched  : 80011406
		Nodes/second    : 637759

		ASSERT外して、gccでコンパイルするか。
		gcc、もう少し速くなるかと思ったのだが…。


] V3.14

	1手0.5秒～3秒で簡単に調整できそうなパラメーターだけ自動調整してみる。
	調整したくないパラメーターはinterval = 9999に設定。

	まずはrazoring marginから。
	0.5秒で大雑把に調整して、そのあと秒数を増やしてみる。


		秒読み100[ms]

		50.4%	
		#227
		やねうら王2016mid V314slave
		slave。1スレッド
		#226
		やねうら王2016mid V314master
		master。1スレッド

		15558-418-15301(7.2% R2.9)	

	停止条件おかしくて止まってなかった。禿げる。



] V3.13

		秒読み400[ms]

		53.8%	
		#224
		やねうら王2016mid V313
		新基準。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		441-6-378(1.3% R26.8)	


	V3.13a
	search()でのevaluate()の呼び出しタイミング、やはり少し遅くしたほうが良いのでは..

		秒読み400[ms]

		48.8%	
		#225
		やねうら王2016mid V313a
		evaluate()遅延。1スレッド
		#224
		やねうら王2016mid V313
		新基準。1スレッド

		186-4-195(69.6% R-8.2)	

	計測不能な差のようなのでこれはいいや。



■　2016/06/20

] V3.12

	V3.12a
	 このkillerの設定、コメントアウトしたほうがいいかも。
	  {
        // IID、singular extension時であっても
        // killerがないときはkillerぐらいは登録したほうが少しだけ得。

        if (ss->killers[0] == MOVE_NONE)
          ss->killers[0] = move;
        else if (ss->killers[1] == MOVE_NONE)
          ss->killers[1] = move;
      }

		秒読み100[ms]

		54.7%	
		#222
		やねうら王2016mid V312a
		IID killerなし。1スレッド
		#221
		やねうら王2016mid V312
		新基準。1スレッド

		248-4-205(1.9% R33.1)	


		秒読み1000[ms]

		52.0%	
		#222
		やねうら王2016mid V312a
		IID killerなし。1スレッド
		#221
		やねうら王2016mid V312
		新基準。1スレッド

		640-27-591(8.1% R13.8)	

	IIDのkiller設定、よくないことがわかった。ばっさり消す。

	V3.12b
	・qsearch()を直接呼び出せるようにした。(学習で用いるので)
	書きかけ。まだ正しく動作しない。

	V3.12c
	ehashあり
		===========================
		Total time (ms) : 141850
		Nodes searched  : 80011406
		Nodes/second    : 564056

	ehashなし
		===========================
		Total time (ms) : 134267
		Nodes searched  : 80011406
		Nodes/second    : 595912

	なしのほうが速いっぽい。これは禿げる..。

	V3.12d
		if (!captureOrPawnPromotion && move != bestMove && quietCount < 64 - 4 + param1 * 4)
		param1 = 0..2
		10秒で魔女と回しておく。


		秒読み10000[ms]

		41.7%	38.6%	43.3%	
		#223
		やねうら王2016mid V312d
		quiet countテスト。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		123-17-172(99.8% R-58.2)	86-11-137(100.0% R-80.9)	97-10-127(98.1% R-46.8)	

		もう少しやらないと何とも…。


] V3.11

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
+      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
+      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。


	Core i7 4771k
	===========================
	Total time (ms) : 150870
	Nodes searched  : 92242005
	Nodes/second    : 611400


		秒読み1000[ms]

		59.5%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		94-5-64(0.7% R66.8)	


		秒読み3000[ms]

		41.4%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		96-10-136(99.7% R-60.5)	


	V3.11a
	historyでdropの+32をやめると？

		-      pc = Piece(pos.piece_on(sq) + (is_drop(move) ? 32 : 0));     \
		+      pc = Piece(pos.piece_on(sq) );     \

  Piece moved_piece_after_ex(Move m) const {
    return is_drop(m)
-      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) + 32)
+      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) /*+ 32*/)
      : is_promote(m) ? Piece(piece_on(move_from(m)) + PIECE_PROMOTE) : piece_on(move_from(m));
  }

-        Piece prevPc = pos.piece_on(prevSq) + Piece(is_drop((ss - 1)->currentMove) ? 32 : 0);
+       Piece prevPc = pos.piece_on(prevSq);


  これで互角なら、この処理なくしたい。
  Moveに移動させる駒が入っていれば、親nodeの移動させる駒が得られて、移動前の駒種でhistoryが
  引けて便利なのかも知れない。(cf. Apery)
  そこで強さに差が出ないなら、そのほうがシンプル。

		秒読み1000[ms]

		48.6%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		297-13-314(76.7% R-9.7)	

	誤差ぐらい。ここでわずかに良くとも、CPU cache汚染とかの問題があるので
	誤差ぐらいしか変わらないなら採用したくないのだが…。

		秒読み3000[ms]

		49.7%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		292-17-295(56.6% R-1.8)	

	ほぼ誤差だな。これは削除すべきか。そうか。

		  // 直前のnodeの指し手で動かした駒(移動後の駒)とその移動先の升を返す。
		  // この実装においてmoved_piece()は使えない。これは現在のPosition::side_to_move()の駒が返るからである。
		  // 駒打ちのときは、駒打ちの駒(+32した駒)が返る。
		#define sq_pc_from_move(sq,pc,move)                                \
			{                                                              \
			  sq = move_to(move);                                          \
			  pc = Piece(pos.piece_on(sq);     \
			}

	V3.11b
	ソースコード整理して、やねうら王2016 MidではUSE_DROPBIT_IN_STATSを使わないようにした。
	以前のバージョンより弱くなっていないかをテスト。

	history、移動前の駒で評価しても棋力変わらないのかも。
	指し手生成のときにmoveの上位bitを移動後の駒にするのは難しくはないのだが。
	というか、成りはquietではないのでhistoryからそもそも除外されているのか？
	除外は歩の成りだけか。うーん。角とか飛車の成り、本当に除外していいのか？
	価値上昇値が、歩の成りよりは低いか。	

		秒読み3000[ms]

		42.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		110-3-149(99.4% R-52.7)	

	あれ？めっちゃ弱くなった。どうなってんの…。

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。

	この省略が得していない？
	ああ、mate1ply()、置換表にhitしたときに省略されるのか。その差だな。
	修正して、再テスト。

		秒読み3000[ms]

		45.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		222-21-266(97.9% R-31.4)	

	やはり悪いのか…。そうなのか…。
	これは戻さざるをえない。

	V3.11c元に戻して0.3秒テスト。
	間違えてた。

		#ifndef USE_DROPBIT_IN_STATS   
			  pos.piece_on(prevSq);
		#else
			  pos.piece_on(prevSq) + Piece(is_drop((ss-1)->currentMove) ? 32 : 0);
		#endif

	こうだった。
	→　これで3.11と互角に戻った。再実験。

	V3.11d
		秒読み300[ms]

		48.3%	
		#214
		やねうら王2016mid V311d
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		703-21-752(90.1% R-11.7)	
	
	短い時間ではCPU cacheの汚染が少ないので勝ち越さなければならないのに
	勝っていないので、これは本当にダメそう。

	V3.11e
	MovePicker、killerの数に応じて、QUIET0,1,2,3とか分岐してはダメか？そこそこ意味があるような？
	Killer、Move32で持つの誤りだった。ExtMoveで持つべきだった。

		===========================
		Total time (ms) : 129748
		Nodes searched  : 74446076
		Nodes/second    : 573774

	比較実験しやすいようにdefineにする。

		// QUIETSの指し手を返すときに、分岐させて、少し高速化する。
		#define FAST_QUIETS

		===========================
		Total time (ms) : 130822
		Nodes searched  : 74446076
		Nodes/second    : 569063

	何も速くなってなかった。禿げた。
	killerまわり修正されたはずなのでV3.10と比較。

		秒読み300[ms]

		53.3%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		357-5-313(4.1% R22.8)	

		秒読み3000[ms]

		44.5%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-5-96(93.6% R-38.3)	
		あとはPGOとeval hashの差か。指し手生成で駒種格納。それからassert()消すと。


		秒読み10000[ms]

		44.7%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		209-28-259(99.1% R-37.3)	

		長い時間で勝率に差があったのは解消した。

	結論的には指し手生成段階で移動先での駒種 + 打ち駒なら32 をしたものを
	上位bitに格納したほうがいいのではということになった。

・moved_piece_after_exがいいどうか検討すべき。
	→　これやはり、それで正しい気がする。

	V3.11f
	aspirationのマージンを3秒で自動調整。

	        delta = Value(18 - 6 + 3 * param1);

	param1 = 0..4ぐらいで勝率を見る

		秒読み3000[ms]

		40.9%	46.8%	48.7%	47.4%	44.7%	
		#216
		やねうら王2016mid V311f
		aspiration調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		61-5-88(98.9% R-63.7)	36-1-41(75.3% R-22.6)	37-2-39(63.4% R-9.1)	36-2-40(71.7% R-18.3)	34-2-42(84.9% R-36.7)	

	V3.11g
	delta = Value(18 - 2 + 1 * param1);
	param1 = 0..4

		秒読み3000[ms]

		46.7%	48.0%	45.2%	51.3%	41.9%	
		#217
		やねうら王2016mid V311g
		aspiration調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		70-6-80(81.5% R-23.2)	72-6-78(71.6% R-13.9)	66-10-80(89.3% R-33.4)	78-4-74(34.3% R9.1)	62-4-86(98.0% R-56.8)	

	回数が少なくてよくわからない。


		// --- Counter Move

		// KEEP_PIECE_IN_COUNTER_MOVEがdefineされていたなら、
		// 移動させた駒を上位16bitに格納しておく。
		// bit24...16 = 移動させた駒(Piece。後手の駒含む)
		// bit15... 0 = 本来のMove

		#ifdef KEEP_PIECE_IN_COUNTER_MOVE
		#define COUNTER_MOVE Move32
		// 指し手の上位に駒種(移動前の駒)を格納してMove32化する。
		#define make_move32(move) ((Move32)((move) + (pos.moved_piece_after_ex(move) << 16)))
		#else
		#define COUNTER_MOVE Move 
		#endif

	このコード完全に削除して、Moveは32bit固定したほうがいいな。

		#ifndef KEEP_PIECE_IN_COUNTER_MOVE
			// しかし、Counter Moveの手は手番に関係ないので(駒種を保持していないなら)取り違える可能性があるため
			// (しかも、その可能性はそこそこ高い)、ここで合法性をチェックする必要がある。
			switch (pr)
			{
			case PAWN:
			case LANCE:
			  if ((us == BLACK && rank_of(to) == RANK_1) || (us == WHITE && rank_of(to) == RANK_9))
				return false;
			  break;
			case KNIGHT:
			  if ((us == BLACK && rank_of(to) < RANK_3) || (us == WHITE && rank_of(to) > RANK_7))
				return false;
			  break;
			}
		#else
			// 変な指し手を渡していないか、assertを入れて調べておく。(ASSERT_LV4以上のとき用)
			switch (pr)
			{
			case PAWN:
			case LANCE:
			  if ((us == BLACK && rank_of(to) == RANK_1) || (us == WHITE && rank_of(to) == RANK_9))
				ASSERT_LV4(false);
			  break;
			case KNIGHT:
			  if ((us == BLACK && rank_of(to) < RANK_3) || (us == WHITE && rank_of(to) > RANK_7))
				ASSERT_LV4(false);
			  break;
			}
		#endif

	V3.11h

	===========================
	Total time (ms) : 110191
	Nodes searched  : 62019533
	Nodes/second    : 562836

	何も速くなってない。なんなん…。

	まだいろいろ指し手生成にバグがあるようだ。
	random playerでデバッグ。

		#if 0
			  cout << pos;
			  for (auto m : mg)
			  {
				auto pc = pos.moved_piece_after_ex(m);
				cout << (Move)m << " " << pc << endl;
			  }
			  cout << endl;
		#endif

		  // ここで生成された指し手がすべて合法手であるかテストをする
		  for (auto m : mg)
		  {
			if (!pos.pseudo_legal(m))
			{
			  auto pc = pos.moved_piece_after_ex(m);
			  cout << pos << (Move)m << " " << pc;
			  pos.pseudo_legal(m);
			}

			ASSERT_LV3(pos.pseudo_legal(m));
			ASSERT_LV2(pos.legal(m));
		  }
		  →　やっとtest通った。

	===========================
	Total time (ms) : 185363
	Nodes searched  : 106442741
	Nodes/second    : 574239

	ほぼ高速化していないというのは指し手生成で余分なコストがかかった分を
	回収できていないのか。MovePickerはシンプルになったが…。

		秒読み100[ms]

		51.6%	
		#218
		やねうら王2016mid V311h
		指し手生成大改造。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		1079-34-1013(7.5% R11.0)	

	悪くはなっていなさそうなので良し。

	V3.11i
		piece_on()使っているところを置き換え。

	      Piece prevPc = pos.moved_piece_after_ex((ss - 1)->currentMove));

			秒読み100[ms]

			52.0%	
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド
			#210
			やねうら王2016mid V311
			新基準。1スレッド

			727-20-670(6.4% R14.2)	

	・clangでのコンパイル通るようにしてUbuntu×AWSで動くようにする。→　tanuki-さんにお願い中。
	→ 魔女ではgccでコンパイルするとVS2015でコンパイルするより15%ぐらい速くなる模様。
	→ gcc + PGOで1,2%ぐらい速くなる模様。VS2015のほうはちっとも..。
		gccでコンパイルしてリリースするか…。

	・classic-tceをビルドして、比較。
		classic-tceのほうがnpsが高い。
		Stockfish7でorderingがすこぶる重くなってnpsが下がったが、長い時間ではそちらのほうが良いようだ。

			秒読み100[ms]

			54.2%	
			#220
			やねうら王classic-tce V311i
			比較基準用。1スレッド
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド

			230-1-194(3.6% R29.6)	


			秒読み1000[ms]

			45.4%	
			#220
			やねうら王classic-tce V311i
			比較基準用。1スレッド
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド

			108-5-130(93.2% R-32.2)	



■　2016/06/18

] PGO

・PGOかける

	Visual Studio Community 2015でK-Shogiをビルドしてみた
	http://blog.studiok-i.net/shogi/1272.html

		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択 ※XXXはプロジェクト名
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – インストルメント」を選択
		リビルドする
		「デバッグ」メニュー ⇒ 「デバッグの開始」
		適当に動かす（最適化してほしいところを集中的に動かすとよい）
		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – 最適化」を選択
		ビルドする（リビルドではない）

	PGO前
	===========================
	Total time (ms) : 126895
	Nodes searched  : 79320741
	Nodes/second    : 625089

	PGO後
	===========================
	Total time (ms) : 124923
	Nodes searched  : 79320741
	Nodes/second    : 634957

	1%ほどしか変わらない。おかしい…。仮想環境だからな..

] V3.10

	・5,10秒で魔女と対戦

	5秒→10秒で勝率が低下する。長い持ち時間になったときに勝率が低下するファクターが
	まだ何か残っているのだと思う。静止探索での一手詰めとかあのへん怪しい。
	assert復活させてPGOなしにしてもう少し実験せねば。

		秒読み5000[ms]
		38.8%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		85-7-134(100.0% R-79.1)	


		秒読み10000[ms]
		32.9%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		199-28-406(100.0% R-123.9)	

	利き更新なし＋1手詰めなしにしたときの10秒での勝率とほぼ変わらない。
	静止探索での1手詰めが長い持ち時間において足を引っ張っている気がする。
	しかし、静止探索のオーバーヘッドだけでそんなに勝率が変わるとは考えにくいので
	他の要因があるはず。

	5秒対戦だとnpsの差で負けている可能性とかもあって、原因がよくわからない。
	10秒対戦での勝率を見ながらチューンするしかない。

		
	短い時間では静止探索での1手詰めの効果は顕著なのだが…。

		秒読み100[ms]

		43.9%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		723-24-923(100.0% R-42.4)	



	静止探索での1手詰めを入れないと弱くなった。
	やはり意味があるように思える。

		秒読み10000[ms]

		27.0%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		31-1-84(100.0% R-173.2)	


	まさかと思うがONE_PLY = 1で試す。
	そうか。futility margin、ONE_PLYで割られていないのでONE_PLY = 2でやっていると
	半分の値でやっていることになるのか…そうか…。
	ならStockfishのfutility margin = 200は100相当なので、わりといまの値に近いのか…。


		秒読み100[ms]

		45.1%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		352-13-429(99.7% R-34.4)	

	少し弱くなった。ONE_PLYの値に影響を受けている何かがあるのか…。
	PGOの差かも知れない。reduction table絡みかも知れない。

		秒読み500[ms]

		49.8%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		138-1-139(54.8% R-1.3)	

	500[ms]だとほぼ変わらずっぽいのでONE_PLY=1のままちょっといろいろいじる。

	V3.10c
	reduction量を変えてみる。

		  for (int imp = 0; imp <= 1; ++imp)
			for (int d = 1; d < 64; ++d)
			  for (int mc = 1; mc < 64; ++mc)
			  {
				double r = log(d) * log(mc) / 2;
				if (r < 0.80)
				  continue;

				reduction_table[NonPV][imp][d][mc] = int(std::round(r)) * ONE_PLY;
				reduction_table[PV][imp][d][mc] = std::max(reduction_table[NonPV][imp][d][mc] - ONE_PLY, DEPTH_ZERO);

				if (!imp && reduction_table[NonPV][imp][d][mc] >= 2 * ONE_PLY)
				  reduction_table[NonPV][imp][d][mc] += ONE_PLY;
			  }

	ONE_PLY = 1と2の差は関係なくて、reductionテーブルは後者のほうが理想に近いのが、
	長時間において差が出る要因なのだろう…。ONE_PLY = 2のほうが各種パラメーターを
	調整しやすいので良いはずなのだが、現状、そこまで細かく調整する価値のあるパラメーターが
	なくて、ONE_PLYで割るコストのほうが高くついているのかも知れない。

		秒読み500[ms]

		49.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		276-8-286(67.9% R-6.2)	

	ほぼ互角。3秒でも変わらなければこちらを採用したほうが良いのでは…。


		秒読み3000[ms]
		59.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		65-3-45(2.2% R63.9)	

	どうも長い時間では新しいreduction tableのほうが有利くさい。(もう少しやったほうが良い)
	長い時間で魔女と勝率に差があく原因の一つはこれなのか？

	魔女と5秒でやらせてみる。


		秒読み5000[ms]

		31.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		66-9-146(100.0% R-137.9)	

	前よりたくさん負け越した。そんな馬鹿な…。
	この際、魔女に近づけて行って、勝率どこで回復するか見たほうが良いのでは..

	V3.10d
	LMR新テーブル + qsearchでのmateなしとのコンボ。
	
		秒読み5000[ms]

		31.7%	
		#196
		やねうら王2016mid V310d
		ONE_PLY=1,reduction変更,qmateなし。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		33-2-71(100.0% R-133.1)	

	よく見たら魔女もqsearchでmate1呼んでた。置換表に書き出していないが…。

	V3.10e
	qmate復活。qmateのタイミングをもう少し早めに変更。
	mate1を見つけたときに置換表に書き出す処理、やめる。

		秒読み5000[ms]

		29.4%	
		#197
		やねうら王2016mid V310e
		qmate復活。呼び出しタイミング調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		55-5-132(100.0% R-152.1)	

	どんどん弱くなっててワロタ。


	V3.10f
	aspirationの幅40->18,深さ7->5

		秒読み5000[ms]

		34.4%	
		#198
		やねうら王2016mid V310f
		aspiration幅変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-8-147(100.0% R-112.3)	

	aspirationまわり変えたら、少し強くなった。
	そうか。Apery向けのaspirationではないので少し損をしていたのか…。

	Aperyのコード以下の部分、fall throughなのか。怖すぎワロタ。
		switch (pos.isDraw(16)) {
		case NotRepetition      : if (!Signals.stop.load(std::memory_order_relaxed) && ss->ply <= MaxPly) { break; }
		case RepetitionDraw     : return ScoreDraw;

	V3.10g
	update_stats()するの、capture or pawn promotionであるべき。

	V3.10h
	すべて↑であるべき。


		秒読み5000[ms]

		36.4%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		68-2-119(100.0% R-97.2)	

	R15ぐらい違うのかな？

		秒読み10000[ms]

		34.7%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		114-14-215(100.0% R-110.2)	

	10秒でもそんなにRは下がらなくなってきた。よしよし。


	USE_DROPBIT_IN_STATS、もしかして無駄である可能性…。
	まあいいや。いまそこが問題ではない。

	あとどこだろ。

	・指し手生成で何か抜けている可能性
	→　quiet + capture = all になるかとかテストすべき。

	・SEE()がおかしい可能性
	→　簡単な探索部と合致するかテストすべき

	・新しく書いたmate1ply()がおかしい可能性
	・評価関数が重い可能性
	
	V3.10i
	利き有効にしてのmate1ply()

		秒読み1000[ms]

		49.4%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		170-6-174(60.6% R-4.0)	


		秒読み3000[ms]

		42.0%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		42-4-58(95.6% R-56.1)	

	はやり遅い分だけやや損なのかも。

	see()書きなおしてみるか。

	V3.10j
	USE_SIMPLE_SEEを用意した。

		bench
		===========================
		Total time (ms) : 442722
		Nodes searched  : 308535061
		Nodes/second    : 696904

	だいぶ速くなった気がする。
	SEE、もう少し速くできる気がする。

		秒読み1000[ms]

		6.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		2-0-28(100.0% R-458.5)	

	20連敗した。SEE、これじゃない感。

	turn間違えてる。
	  Color turn = ~(is_drop(move) ? sideToMove : color_of(piece_on(move_from(move))));
	いま、seeの順番、金があとになってるのよくない気はする。
	あと、攻撃の有無間違えてた。あれだけでこんなに勝率下がるのか。そうか…。

		秒読み100[ms]

		22.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		20-0-68(100.0% R-212.6)	

	めっちゃ弱くなっとる。よく調べる。
	see()の前提処理まちごてた。修正した。

	see()前のコードも最後KING+1を返しているの、これおかしい気がしてきた。そうか…。
	と金で何かを取るとき、これがKING扱いになっていたのか。修正した。

		===========================
		Total time (ms) : 189502
		Nodes searched  : 108434227
		Nodes/second    : 572206

	
		秒読み300[ms]

		39.3%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		132-5-204(100.0% R-75.6)	

	新SEE、バグってるんやろか。元のSEEに戻してテスト。

	V3.10k

		秒読み300[ms]

		49.8%	
		#203
		やねうら王2016mid V310k
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		311-10-313(54.8% R-1.1)	

	SEE直したはずなのだが、勝率に影響がない。そんなもんなのか…。
	
	min_attacker()さらになおした。orderingも改善したはず…だが？

	V3.10l

		// 歩、香、桂、銀、金、角、飛…の順で取るのに使う駒を調べる。

		Bitboard b;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_PAWN  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_LANCE ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_KNIGHT][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_SILVER][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_GOLD  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm] | pos.king_square(stm)); if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm] | pos.king_square(stm)); if (b) goto found;

		// ここでサイクルは停止するのだ。
	#ifndef USE_SIMPLE_SEE
		uncapValue = VALUE_ZERO;
	#endif
		return KING;

	わりとわかりやすい気がする。


		秒読み300[ms]

		48.7%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		364-13-383(76.8% R-8.8)	

	わずかに遅くなった分、回収できていないのか…？

	// この駒が成れるなら、成りの値を返すべき。
	// ※　最後にこの地点に残る駒を返すべきなのか。相手が取る/取らないを選択するので。
	Piece pt = type_of(pos.piece_on(sq));
	if (!(pt & PIECE_PROMOTE) && (pt != GOLD)
		&& (canPromote(stm, to) || canPromote(stm,sq)))
		// 成りは敵陣へと、敵陣からの二種類あるので…。
	{

#ifndef USE_SIMPLE_SEE
		uncapValue = ProDiffPieceValue[pt]; // この駒が取り返せなかったときこの分、最後に損をする。
#endif
		return pt;
	}

	→　ちゃんと書いた。

		秒読み300[ms]

		50.0%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		525-19-524(48.8% R0.3)	

	やっと前のものと等価ぐらいになった。

	新see()なおってたりしないのか。
	V3.10m

		秒読み300[ms]

		41.8%	
		#205
		やねうら王2016mid V310m
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		147-5-205(99.9% R-57.8)	

	落ちなくはなったが弱い。まだ何かバグがある模様。
	まあいいや。これはまた時間あるときにデバッグしよう。
	
	V3.10n
	futility margin = 200など

		秒読み3000[ms]

		42.1%	
		#206
		やねうら王2016mid V310n
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		174-12-239(99.9% R-55.1)	

	差が縮まってきた…？

	V3.10o

	// 捕獲から逃れる指し手はreduction量を減らす。
	→　これ意味不明だった。どういうトリックかよくわからない。
	これ、コメントアウトしたほうがよさげ。
	see()の仕様がこちらの想定と違うのだが、それを考慮しても、
	Stockfishのコードはバグっているとしか思えない。

	null moveのreduction等を戻す。

		秒読み3000[ms]

		41.8%	
		#207
		やねうら王2016mid V310o
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		46-2-64(96.5% R-57.4)	


	V3.10p

-        pv[0] = MOVE_NONE;
+        (ss+1)->pv[0] = MOVE_NONE;

	なんぞこれ。間違えてた。

	魔女、fail lowたときに直前の指し手にボーナスを与える条件、間違っているような…。
		else if (depth >= 3 * OnePly
		  && bestMove.isNone() //!bestMove
		  && !inCheck
-		  && !ttMove.isCapture()//!move.cap()
+		  && !pos.captured_piece_type()
		  && (ss-1)->currentMove.is_ok())

	historyのupdateで打ち駒を+32してないところがあった。修正した。
	
	魔女より15%ぐらい遅いのかも知れない。(R40相当？)
	評価関数の差分計算とMoveの構造体、考えなおしたほうがよさ気。

		秒読み3000[ms]

		43.9%	
		#208
		やねうら王2016mid V310p
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		47-5-60(91.2% R-42.4)	

	npsの差程度に落ち着いてきた？寝る前に10秒で回しておく。
	せっかくなのでfutilityの幅を変える実験でもしておく。

	V3.10q
		  Value futility_margin(Depth d, int game_ply) {
			return Value(d * (PARAM_FUTILITY_MARGIN_ALPHA + param1 * 10 - 20) / ONE_PLY);
		  }

	Move32bit化、bit layout考えなおしたほうがよさ気。
	移動させる駒、上位16bitに格納するなら、駒打ちをそのbit5に格納したほうがいいような。
	historyで打ち駒を本当に分けたほうがいいのかはよくわからないが。
	historyにおいて、移動させる元の駒でorderingすべきなのか、そのあとの駒でorderingすべきか。
	指し手生成のときにそこまで生成すべきかどうか悩むな。


		秒読み10000[ms]

		41.1%	37.2%	37.5%	36.3%	39.6%	
		#209
		やねうら王2016mid V310q
		futility実験。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		129-18-185(99.9% R-62.6)	110-16-186(100.0% R-91.2)	112-13-187(100.0% R-89.0)	110-9-193(100.0% R-97.7)	120-9-183(100.0% R-73.3)	

	futility margin 180にしておくか。

